<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20171226103610.1"><vh>@settings</vh>
<v t="leo.20171226103610.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="leo.20171226103610.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="leo.20171226165445.1"><vh>Reference</vh></v>
<v t="leo.20171226105217.1"><vh>@button mingw32-make</vh></v>
<v t="leo.20171226105123.1" a="E"><vh>@path ./../</vh>
<v t="leo.20171226105055.1"><vh>@edit README.md</vh></v>
<v t="leo.20171226105532.1"><vh>@edit Makefile</vh></v>
</v>
<v t="leo.20171226103559.1"><vh>importer script</vh></v>
<v t="leo.20171226103826.1" a="E"><vh>imported files</vh>
<v t="leo.20171226103826.2" a="E"><vh>@path ./../</vh>
<v t="leo.20171226104507.1" a="E"><vh>@@clean PyDemo.py</vh>
<v t="leo.20171226104507.2"><vh>Declarations</vh></v>
<v t="leo.20171226104507.3"><vh>Example3d</vh></v>
<v t="leo.20171226104507.4"><vh>Example2d</vh></v>
</v>
<v t="leo.20171226104343.1" a="E"><vh>@path example</vh>
<v t="leo.20171226104343.4"><vh>@@clean example_crank_rocker.py</vh>
<v t="leo.20171226104343.5"><vh>Declarations</vh></v>
<v t="leo.20171226104343.6"><vh>crank_rock</vh></v>
</v>
<v t="leo.20171226104343.7"><vh>@@clean example_crank_rocker_draw.py</vh>
<v t="leo.20171226111411.1"><vh>Declarations</vh></v>
<v t="leo.20171226111411.2"><vh>crank_rocker</vh></v>
</v>
</v>
<v t="leo.20171226104022.1" a="E"><vh>@path src</vh>
<v t="leo.20171226113822.1"><vh>@edit slvs.i</vh></v>
<v t="leo.20171226113829.1"><vh>@edit slvs_python.hpp</vh></v>
<v t="leo.20171226104022.2"><vh>@@clean constraint.cpp</vh>
<v t="leo.20171226104022.3"><vh>void Constraint::DeleteAllConstraintsFor</vh></v>
<v t="leo.20171226104022.4"><vh>bool other</vh></v>
<v t="leo.20171226104022.5"><vh>void Constraint::MenuConstrain</vh>
<v t="leo.20171226104022.6"><vh>const raint</vh></v>
</v>
</v>
<v t="leo.20171226104022.7"><vh>@@clean constrainteq.cpp</vh>
<v t="leo.20171226104022.8"><vh>bool ConstraintBase::HasLabel</vh></v>
<v t="leo.20171226104022.9"><vh>void ConstraintBase::ModifyToSatisfy</vh></v>
<v t="leo.20171226104022.10"><vh>void ConstraintBase::AddEq</vh></v>
<v t="leo.20171226104022.11"><vh>void ConstraintBase::AddEq</vh></v>
<v t="leo.20171226104022.12"><vh>void ConstraintBase::Generate</vh></v>
<v t="leo.20171226104022.13"><vh>void ConstraintBase::GenerateEquations</vh></v>
</v>
<v t="leo.20171226104022.14"><vh>@@clean entity.cpp</vh>
<v t="leo.20171226104022.15"><vh>bool EntityBase::HasVector</vh></v>
<v t="leo.20171226104022.16"><vh>bool EntityBase::IsCircle</vh></v>
<v t="leo.20171226104022.17"><vh>void EntityBase::ArcGetAngles</vh></v>
<v t="leo.20171226104022.18"><vh>bool EntityBase::IsWorkplane</vh></v>
<v t="leo.20171226104022.19"><vh>void EntityBase::WorkplaneGetPlaneExprs</vh></v>
<v t="leo.20171226104022.20"><vh>bool EntityBase::IsDistance</vh></v>
<v t="leo.20171226104022.21"><vh>void EntityBase::DistanceForceTo</vh></v>
<v t="leo.20171226104022.22"><vh>bool EntityBase::IsPoint</vh></v>
<v t="leo.20171226104022.23"><vh>bool EntityBase::IsNormal</vh></v>
<v t="leo.20171226104022.24"><vh>void EntityBase::NormalForceTo</vh></v>
<v t="leo.20171226104022.25"><vh>void EntityBase::PointForceParamTo</vh></v>
<v t="leo.20171226104022.26"><vh>void EntityBase::PointForceTo</vh></v>
<v t="leo.20171226104022.27"><vh>void EntityBase::PointGetExprsInWorkplane</vh></v>
<v t="leo.20171226104022.28"><vh>void EntityBase::PointForceQuaternionTo</vh></v>
<v t="leo.20171226104022.29"><vh>bool EntityBase::IsFace</vh></v>
<v t="leo.20171226104022.30"><vh>bool EntityBase::HasEndpoints</vh></v>
<v t="leo.20171226104022.31"><vh>void EntityBase::RectGetPointsExprs</vh></v>
<v t="leo.20171226104022.32"><vh>void EntityBase::AddEq</vh></v>
<v t="leo.20171226104022.33"><vh>void EntityBase::GenerateEquations</vh></v>
</v>
<v t="leo.20171226104022.34"><vh>@@clean expr.cpp</vh>
<v t="leo.20171226104022.35"><vh>int Expr::Children</vh></v>
<v t="leo.20171226104022.36"><vh>int Expr::Nodes</vh></v>
<v t="leo.20171226104022.37"><vh>bool Expr::DependsOn</vh></v>
<v t="leo.20171226104022.38"><vh>bool Expr::Tol</vh></v>
<v t="leo.20171226104022.39"><vh>void Expr::Substitute</vh></v>
<v t="leo.20171226104022.40"><vh>class ExprParser</vh>
<v t="leo.20171226104022.41"><vh>class Token</vh></v>
</v>
<v t="leo.20171226104022.42"><vh>char ExprParser::ReadChar</vh></v>
<v t="leo.20171226104022.43"><vh>char ExprParser::PeekChar</vh></v>
<v t="leo.20171226104022.44"><vh>void ExprParser::SkipSpace</vh></v>
<v t="leo.20171226104022.45"><vh>int ExprParser::Precedence</vh></v>
<v t="leo.20171226104022.46"><vh>bool ExprParser::Reduce</vh></v>
<v t="leo.20171226104022.47"><vh>bool ExprParser::Parse</vh></v>
</v>
<v t="leo.20171226104022.48"><vh>@@clean lib.cpp</vh>
<v t="leo.20171226104022.49"><vh>void Group::GenerateEquations</vh></v>
<v t="leo.20171226104022.50"><vh>void SolveSpace::CnfFreezeInt</vh></v>
<v t="leo.20171226104022.51"><vh>void SolveSpace::DoMessageBox</vh></v>
<v t="leo.20171226104022.52"><vh>extern "C" {</vh>
<v t="leo.20171226104022.53"><vh>void Slvs_QuaternionU</vh></v>
<v t="leo.20171226104022.54"><vh>void Slvs_QuaternionV</vh></v>
<v t="leo.20171226104022.55"><vh>void Slvs_QuaternionN</vh></v>
<v t="leo.20171226104022.56"><vh>void Slvs_MakeQuaternion</vh></v>
<v t="leo.20171226104022.57"><vh>void Slvs_Solve</vh></v>
</v>
</v>
<v t="leo.20171226104022.58"><vh>@@clean system.cpp</vh>
<v t="leo.20171226104022.59"><vh>bool System::WriteJacobian</vh></v>
<v t="leo.20171226104022.60"><vh>void System::EvalJacobian</vh></v>
<v t="leo.20171226104022.61"><vh>bool System::IsDragged</vh></v>
<v t="leo.20171226104022.62"><vh>void System::SolveBySubstitution</vh></v>
<v t="leo.20171226104022.63"><vh>int System::CalculateRank</vh></v>
<v t="leo.20171226104022.64"><vh>bool System::TestRank</vh></v>
<v t="leo.20171226104022.65"><vh>bool System::SolveLinearSystem</vh></v>
<v t="leo.20171226104022.66"><vh>bool System::SolveLeastSquares</vh></v>
<v t="leo.20171226104022.67"><vh>bool System::NewtonSolve</vh></v>
<v t="leo.20171226104022.68"><vh>void System::WriteEquationsExceptFor</vh></v>
<v t="leo.20171226104022.69"><vh>void System::FindWhichToRemoveToFixJacobian</vh></v>
<v t="leo.20171226104022.70"><vh>bool andFindBad</vh></v>
<v t="leo.20171226104022.71"><vh>bool andFindBad</vh></v>
<v t="leo.20171226104022.72"><vh>void System::Clear</vh></v>
<v t="leo.20171226104022.73"><vh>void System::MarkParamsFree</vh></v>
<v t="leo.20171226104022.74"><vh>int System::CalculateDof</vh></v>
</v>
<v t="leo.20171226104022.75"><vh>@@clean util.cpp</vh>
<v t="leo.20171226104022.76"><vh>char 32_t</vh></v>
<v t="leo.20171226104022.77"><vh>int 64_t</vh></v>
<v t="leo.20171226104022.78"><vh>void SolveSpace::MakeMatrix</vh></v>
<v t="leo.20171226104022.79"><vh>void SolveSpace::MultMatrix</vh></v>
<v t="leo.20171226104022.80"><vh>void DoStringForMessageBox</vh></v>
<v t="leo.20171226104022.81"><vh>void SolveSpace::Error</vh></v>
<v t="leo.20171226104022.82"><vh>void SolveSpace::Message</vh></v>
<v t="leo.20171226104022.83"><vh>void BandedMatrix::Solve</vh></v>
<v t="leo.20171226104022.84"><vh>bool Vector::Equals</vh></v>
<v t="leo.20171226104022.85"><vh>bool Vector::EqualsExactly</vh></v>
<v t="leo.20171226104022.86"><vh>bool Vector::OnLineSegment</vh></v>
<v t="leo.20171226104022.87"><vh>void Vector::MakeMaxMin</vh></v>
<v t="leo.20171226104022.88"><vh>bool Vector::OutsideAndNotOn</vh></v>
<v t="leo.20171226104022.89"><vh>bool Vector::BoundingBoxesDisjoint</vh></v>
<v t="leo.20171226104022.90"><vh>bool Vector::BoundingBoxIntersectsLine</vh></v>
<v t="leo.20171226104022.91"><vh>double det2</vh></v>
<v t="leo.20171226104022.92"><vh>double det3</vh></v>
<v t="leo.20171226104022.93"><vh>double det</vh></v>
<v t="leo.20171226104022.94"><vh>bool VectorPred::operator</vh></v>
<v t="leo.20171226104022.95"><vh>bool Point2d::Equals</vh></v>
<v t="leo.20171226104022.96"><vh>void BBox::Include</vh></v>
<v t="leo.20171226104022.97"><vh>bool BBox::Overlaps</vh></v>
<v t="leo.20171226104022.98"><vh>bool BBox::Contains</vh></v>
<v t="leo.20171226104022.99"><vh>const std::vector</vh></v>
</v>
<v t="leo.20171226104022.100"><vh>@path platform</vh>
<v t="leo.20171226104022.101"><vh>@@clean platform.cpp</vh>
<v t="leo.20171226104022.102"><vh>static std::vector</vh></v>
<v t="leo.20171226104022.103"><vh>static std::string</vh></v>
<v t="leo.20171226104022.104"><vh>bool Path::HasExtension</vh></v>
<v t="leo.20171226104022.105"><vh>void FindPrefix</vh></v>
<v t="leo.20171226104022.106"><vh>bool Path::IsAbsolute</vh></v>
<v t="leo.20171226104022.107"><vh>static std::string</vh></v>
<v t="leo.20171226104022.108"><vh>bool Path::Equals</vh></v>
<v t="leo.20171226104022.109"><vh>void RemoveFile</vh></v>
<v t="leo.20171226104022.110"><vh>bool ReadFile</vh></v>
<v t="leo.20171226104022.111"><vh>bool WriteFile</vh></v>
<v t="leo.20171226104022.112"><vh>const void *LoadResource(const std::string &amp;name, size_t *size) {</vh></v>
<v t="leo.20171226104022.113"><vh>static Platform::Path</vh></v>
<v t="leo.20171226104022.114"><vh>static Platform::Path</vh></v>
<v t="leo.20171226104022.115"><vh>static Platform::Path</vh></v>
<v t="leo.20171226104022.116"><vh>static Platform::Path</vh></v>
<v t="leo.20171226104022.117"><vh>const void *LoadResource(const std::string &amp;name, size_t *size) {</vh></v>
</v>
<v t="leo.20171226104022.118"><vh>@@clean unixutil.cpp</vh>
<v t="leo.20171226104022.119"><vh>void dbp</vh></v>
<v t="leo.20171226104022.120"><vh>void assert_failure</vh></v>
<v t="leo.20171226104022.121"><vh>typedef struct</vh></v>
<v t="leo.20171226104022.122"><vh>void *AllocTemporary(size_t n)</vh></v>
<v t="leo.20171226104022.123"><vh>void FreeTemporary</vh></v>
<v t="leo.20171226104022.124"><vh>void FreeAllTemporary</vh></v>
<v t="leo.20171226104022.125"><vh>void *MemAlloc(size_t n) {</vh></v>
<v t="leo.20171226104022.126"><vh>void MemFree</vh></v>
</v>
<v t="leo.20171226104022.127"><vh>@@clean w32util.cpp</vh>
<v t="leo.20171226104022.128"><vh>void dbp</vh></v>
<v t="leo.20171226104022.129"><vh>void assert_failure</vh></v>
<v t="leo.20171226104022.130"><vh>void *AllocTemporary(size_t n)</vh></v>
<v t="leo.20171226104022.131"><vh>void FreeTemporary</vh></v>
<v t="leo.20171226104022.132"><vh>void FreeAllTemporary</vh></v>
<v t="leo.20171226104022.133"><vh>void *MemAlloc(size_t n) {</vh></v>
<v t="leo.20171226104022.134"><vh>void MemFree</vh></v>
<v t="leo.20171226104022.135"><vh>void vl</vh></v>
</v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="leo.20171226103559.1">'''Recursively import all ['.cpp'] files in a directory and clean the result.'''

# Latest change: use c.recursiveImport.

c.recursiveImport(
    dir_ = r'./../../',
    kind = '@clean',
    safe_at_file = True,
    theTypes = ['.cpp']
)</t>
<t tx="leo.20171226103610.1"></t>
<t tx="leo.20171226103610.2">QSplitter::handle {
    background-color: #CAE1FF; /* lightSteelBlue1 */
}

QStackedWidget {
    /* background-color:lightpink; */
    border-color: red;
    padding: 0px;
    /* border-width: 0px; */
    /* background-color: yellow; */
}

QSplitter {
    border-color: white;
    background-color: white;
    border-style: solid;
}

QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="leo.20171226103610.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="leo.20171226103826.1"></t>
<t tx="leo.20171226103826.2"></t>
<t tx="leo.20171226104022.1"></t>
<t tx="leo.20171226104022.10">void ConstraintBase::AddEq(IdList&lt;Equation,hEquation&gt; *l, Expr *expr, int index) const
{
    Equation eq;
    eq.e = expr;
    eq.h = h.equation(index);
    l-&gt;Add(&amp;eq);
}

</t>
<t tx="leo.20171226104022.100"></t>
<t tx="leo.20171226104022.101">//-----------------------------------------------------------------------------
// Platform-dependent functionality.
//
// Copyright 2017 whitequark
//-----------------------------------------------------------------------------
#if defined(__APPLE__)
// Include Apple headers before solvespace.h to avoid identifier clashes.
#   include &lt;CoreFoundation/CFString.h&gt;
#   include &lt;CoreFoundation/CFURL.h&gt;
#   include &lt;CoreFoundation/CFBundle.h&gt;
#endif
#include "solvespace.h"
#include "config.h"
#if defined(WIN32)
// Conversely, include Microsoft headers after solvespace.h to avoid clashes.
#   include &lt;windows.h&gt;
#else
#   include &lt;unistd.h&gt;
#   include &lt;sys/stat.h&gt;
#endif

namespace SolveSpace {
namespace Platform {

//-----------------------------------------------------------------------------
// UTF-8 ⟷ UTF-16 conversion, on Windows.
//-----------------------------------------------------------------------------

#if defined(WIN32)

std::string Narrow(const wchar_t *in)
{
    std::string out;
    DWORD len = WideCharToMultiByte(CP_UTF8, 0, in, -1, NULL, 0, NULL, NULL);
    out.resize(len - 1);
    ssassert(WideCharToMultiByte(CP_UTF8, 0, in, -1, &amp;out[0], len, NULL, NULL),
             "Invalid UTF-16");
    return out;
}

std::string Narrow(const std::wstring &amp;in)
{
    if(in == L"") return "";

    std::string out;
    out.resize(WideCharToMultiByte(CP_UTF8, 0, &amp;in[0], (int)in.length(),
                                   NULL, 0, NULL, NULL));
    ssassert(WideCharToMultiByte(CP_UTF8, 0, &amp;in[0], (int)in.length(),
                                 &amp;out[0], (int)out.length(), NULL, NULL),
             "Invalid UTF-16");
    return out;
}

std::wstring Widen(const char *in)
{
    std::wstring out;
    DWORD len = MultiByteToWideChar(CP_UTF8, 0, in, -1, NULL, 0);
    out.resize(len - 1);
    ssassert(MultiByteToWideChar(CP_UTF8, 0, in, -1, &amp;out[0], len),
             "Invalid UTF-8");
    return out;
}

std::wstring Widen(const std::string &amp;in)
{
    if(in == "") return L"";

    std::wstring out;
    out.resize(MultiByteToWideChar(CP_UTF8, 0, &amp;in[0], (int)in.length(), NULL, 0));
    ssassert(MultiByteToWideChar(CP_UTF8, 0, &amp;in[0], (int)in.length(),
                                 &amp;out[0], (int)out.length()),
             "Invalid UTF-8");
    return out;
}

#endif

//-----------------------------------------------------------------------------
// Path utility functions.
//-----------------------------------------------------------------------------

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20171226104022.102">static std::vector&lt;std::string&gt; Split(const std::string &amp;joined, char separator) {
    std::vector&lt;std::string&gt; parts;

    size_t oldpos = 0, pos = 0;
    while(true) {
        oldpos = pos;
        pos = joined.find(separator, pos);
        if(pos == std::string::npos) break;
        parts.push_back(joined.substr(oldpos, pos - oldpos));
        pos += 1;
    }

    if(oldpos != joined.length() - 1) {
        parts.push_back(joined.substr(oldpos));
    }

    return parts;
}

</t>
<t tx="leo.20171226104022.103">static std::string Concat(const std::vector&lt;std::string&gt; &amp;parts, char separator) {
    std::string joined;

    bool first = true;
    for(auto &amp;part : parts) {
        if(!first) joined += separator;
        joined += part;
        first = false;
    }

    return joined;
}

//-----------------------------------------------------------------------------
// Path manipulation.
//-----------------------------------------------------------------------------

#if defined(WIN32)
const char SEPARATOR = '\\';
#else
const char SEPARATOR = '/';
#endif

Path Path::From(std::string raw) {
    Path path = { raw };
    return path;
}

Path Path::CurrentDirectory() {
#if defined(WIN32)
    // On Windows, OpenFile needs an absolute UNC path proper, so get that.
    std::wstring rawW;
    rawW.resize(GetCurrentDirectoryW(0, NULL));
    DWORD length = GetCurrentDirectoryW((int)rawW.length(), &amp;rawW[0]);
    ssassert(length &gt; 0 &amp;&amp; length == rawW.length() - 1, "Cannot get current directory");
    rawW.resize(length);
    return From(Narrow(rawW));
#else
    char *raw = getcwd(NULL, 0);
    ssassert(raw != NULL, "Cannot get current directory");
    Path path = From(raw);
    free(raw);
    return path;
#endif
}

std::string Path::FileName() const {
    std::string fileName = raw;
    size_t slash = fileName.rfind(SEPARATOR);
    if(slash != std::string::npos) {
        fileName = fileName.substr(slash + 1);
    }
    return fileName;
}

std::string Path::FileStem() const {
    std::string baseName = FileName();
    size_t dot = baseName.rfind('.');
    if(dot != std::string::npos) {
        baseName = baseName.substr(0, dot);
    }
    return baseName;
}

std::string Path::Extension() const {
    size_t dot = raw.rfind('.');
    if(dot != std::string::npos) {
        return raw.substr(dot + 1);
    }
    return "";
}

</t>
<t tx="leo.20171226104022.104">bool Path::HasExtension(std::string theirExt) const {
    std::string ourExt = Extension();
    std::transform(ourExt.begin(),   ourExt.end(),   ourExt.begin(),   ::tolower);
    std::transform(theirExt.begin(), theirExt.end(), theirExt.begin(), ::tolower);
    return ourExt == theirExt;
}

Path Path::WithExtension(std::string ext) const {
    Path withExt = *this;
    size_t dot = withExt.raw.rfind('.');
    if(dot != std::string::npos) {
        withExt.raw.erase(dot);
    }
    withExt.raw += ".";
    withExt.raw += ext;
    return withExt;
}

</t>
<t tx="leo.20171226104022.105">static void FindPrefix(const std::string &amp;raw, size_t *pos) {
    *pos = std::string::npos;
#if defined(WIN32)
    if(raw.size() &gt;= 7 &amp;&amp; raw[2] == '?' &amp;&amp; raw[3] == '\\' &amp;&amp;
            isalpha(raw[4]) &amp;&amp; raw[5] == ':' &amp;&amp; raw[6] == '\\') {
        *pos = 7;
    } else if(raw.size() &gt;= 3 &amp;&amp; isalpha(raw[0]) &amp;&amp; raw[1] == ':' &amp;&amp; raw[2] == '\\') {
        *pos = 3;
    } else if(raw.size() &gt;= 2 &amp;&amp; raw[0] == '\\' &amp;&amp; raw[1] == '\\') {
        size_t slashAt = raw.find('\\', 2);
        if(slashAt != std::string::npos) {
            *pos = raw.find('\\', slashAt + 1);
        }
    }
#else
    if(raw.size() &gt;= 1 &amp;&amp; raw[0] == '/') {
        *pos = 1;
    }
#endif
}

</t>
<t tx="leo.20171226104022.106">bool Path::IsAbsolute() const {
    size_t pos;
    FindPrefix(raw, &amp;pos);
    return pos != std::string::npos;
}

// Removes one component from the end of the path.
// Returns an empty path if the path consists only of a root.
Path Path::Parent() const {
    Path parent = { raw };
    if(!parent.raw.empty() &amp;&amp; parent.raw.back() == SEPARATOR) {
        parent.raw.pop_back();
    }
    size_t slash = parent.raw.rfind(SEPARATOR);
    if(slash != std::string::npos) {
        parent.raw = parent.raw.substr(0, slash + 1);
    } else {
        parent.raw.clear();
    }
    if(IsAbsolute() &amp;&amp; !parent.IsAbsolute()) {
        return From("");
    }
    return parent;
}

// Concatenates a component to this path.
// Returns an empty path if this path or the component is empty.
Path Path::Join(const std::string &amp;component) const {
    ssassert(component.find(SEPARATOR) == std::string::npos,
             "Use the Path::Join(const Path &amp;) overload to append an entire path");
    return Join(Path::From(component));
}

// Concatenates a relative path to this path.
// Returns an empty path if either path is empty, or the other path is absolute.
Path Path::Join(const Path &amp;other) const {
    if(IsEmpty() || other.IsEmpty() || other.IsAbsolute()) {
        return From("");
    }

    Path joined = { raw };
    if(joined.raw.back() != SEPARATOR) {
        joined.raw += SEPARATOR;
    }
    joined.raw += other.raw;
    return joined;
}

// Expands the "." and ".." components in this path.
// On Windows, additionally prepends the UNC prefix to absolute paths without one.
// Returns an empty path if a ".." component would escape from the root.
Path Path::Expand(bool fromCurrentDirectory) const {
    Path source;
    Path expanded;

    if(fromCurrentDirectory &amp;&amp; !IsAbsolute()) {
        source = CurrentDirectory().Join(*this);
    } else {
        source = *this;
    }

    size_t splitAt;
    FindPrefix(source.raw, &amp;splitAt);
    if(splitAt != std::string::npos) {
        expanded.raw = source.raw.substr(0, splitAt);
    } else {
        splitAt = 0;
    }

    std::vector&lt;std::string&gt; expandedComponents;
    for(std::string component : Split(source.raw.substr(splitAt), SEPARATOR)) {
        if(component == ".") {
            // skip
        } else if(component == "..") {
            if(!expandedComponents.empty()) {
                expandedComponents.pop_back();
            } else {
                return From("");
            }
        } else if(!component.empty()) {
            expandedComponents.push_back(component);
        }
    }

    if(expanded.IsEmpty()) {
        if(expandedComponents.empty()) {
            expandedComponents.push_back(".");
        }
        expanded = From(Concat(expandedComponents, SEPARATOR));
    } else if(!expandedComponents.empty()) {
        expanded = expanded.Join(From(Concat(expandedComponents, SEPARATOR)));
    }

#if defined(WIN32)
    if(expanded.IsAbsolute() &amp;&amp; expanded.raw.substr(0, 2) != "\\\\") {
        expanded.raw = "\\\\?\\" + expanded.raw;
    }
#endif

    return expanded;
}

</t>
<t tx="leo.20171226104022.107">static std::string FilesystemNormalize(const std::string &amp;str) {
#if defined(WIN32)
    std::wstring strW = Widen(str);
    std::transform(strW.begin(), strW.end(), strW.begin(), towlower);
    return Narrow(strW);
#elif defined(__APPLE__)
    CFMutableStringRef cfStr =
        CFStringCreateMutableCopy(NULL, 0,
            CFStringCreateWithBytesNoCopy(NULL, (const UInt8*)str.data(), str.size(),
                kCFStringEncodingUTF8, /*isExternalRepresentation=*/false, kCFAllocatorNull));
    CFStringLowercase(cfStr, NULL);
    std::string normalizedStr;
    normalizedStr.resize(CFStringGetMaximumSizeOfFileSystemRepresentation(cfStr));
    CFStringGetFileSystemRepresentation(cfStr, &amp;normalizedStr[0], normalizedStr.size());
    normalizedStr.erase(normalizedStr.find('\0'));
    return normalizedStr;
#else
    return str;
#endif
}

</t>
<t tx="leo.20171226104022.108">bool Path::Equals(const Path &amp;other) const {
    return FilesystemNormalize(raw) == FilesystemNormalize(other.raw);
}

// Returns a relative path from a given base path.
// Returns an empty path if any of the paths is not absolute, or
// if they belong to different roots, or
// if they cannot be expanded.
Path Path::RelativeTo(const Path &amp;base) const {
    Path expanded = Expand();
    Path baseExpanded = base.Expand();
    if(!(expanded.IsAbsolute() &amp;&amp; baseExpanded.IsAbsolute())){
        return From("");
    }

    size_t splitAt;
    FindPrefix(expanded.raw, &amp;splitAt);
    size_t baseSplitAt;
    FindPrefix(baseExpanded.raw, &amp;baseSplitAt);
    if(FilesystemNormalize(expanded.raw.substr(0, splitAt)) !=
            FilesystemNormalize(baseExpanded.raw.substr(0, splitAt))) {
        return From("");
    }

    std::vector&lt;std::string&gt; components =
        Split(expanded.raw.substr(splitAt), SEPARATOR);
    std::vector&lt;std::string&gt; baseComponents =
        Split(baseExpanded.raw.substr(baseSplitAt), SEPARATOR);
    size_t common;
    for(common = 0; common &lt; baseComponents.size() &amp;&amp;
                    common &lt; components.size(); common++) {
        if(FilesystemNormalize(baseComponents[common]) !=
                FilesystemNormalize(components[common])) {
            break;
        }
    }

    std::vector&lt;std::string&gt; resultComponents;
    for(size_t i = common; i &lt; baseComponents.size(); i++) {
        resultComponents.push_back("..");
    }
    resultComponents.insert(resultComponents.end(),
                            components.begin() + common, components.end());
    if(resultComponents.empty()) {
        resultComponents.push_back(".");
    }
    return From(Concat(resultComponents, SEPARATOR));
}

Path Path::FromPortable(const std::string &amp;repr) {
    return From(Concat(Split(repr, '/'), SEPARATOR));
}

std::string Path::ToPortable() const {
    ssassert(!IsAbsolute(), "absolute paths cannot be made portable");

    return Concat(Split(raw, SEPARATOR), '/');
}

//-----------------------------------------------------------------------------
// File manipulation.
//-----------------------------------------------------------------------------

FILE *OpenFile(const Platform::Path &amp;filename, const char *mode) {
    ssassert(filename.raw.length() == strlen(filename.raw.c_str()),
             "Unexpected null byte in middle of a path");
#if defined(WIN32)
    return _wfopen(Widen(filename.Expand().raw).c_str(), Widen(mode).c_str());
#else
    return fopen(filename.raw.c_str(), mode);
#endif
}

</t>
<t tx="leo.20171226104022.109">void RemoveFile(const Platform::Path &amp;filename) {
    ssassert(filename.raw.length() == strlen(filename.raw.c_str()),
             "Unexpected null byte in middle of a path");
#if defined(WIN32)
    _wremove(Widen(filename.Expand().raw).c_str());
#else
    remove(filename.raw.c_str());
#endif
}

</t>
<t tx="leo.20171226104022.11">void ConstraintBase::AddEq(IdList&lt;Equation,hEquation&gt; *l, const ExprVector &amp;v,
                           int baseIndex) const {
    AddEq(l, v.x, baseIndex);
    AddEq(l, v.y, baseIndex + 1);
    if(workplane.v == EntityBase::FREE_IN_3D.v) {
        AddEq(l, v.z, baseIndex + 2);
    }
}

</t>
<t tx="leo.20171226104022.110">bool ReadFile(const Platform::Path &amp;filename, std::string *data) {
    FILE *f = OpenFile(filename, "rb");
    if(f == NULL) return false;

    fseek(f, 0, SEEK_END);
    data-&gt;resize(ftell(f));
    fseek(f, 0, SEEK_SET);
    fread(&amp;(*data)[0], 1, data-&gt;size(), f);
    fclose(f);

    return true;
}

</t>
<t tx="leo.20171226104022.111">bool WriteFile(const Platform::Path &amp;filename, const std::string &amp;data) {
    FILE *f = OpenFile(filename, "wb");
    if(f == NULL) return false;

    fwrite(&amp;data[0], 1, data.size(), f);
    fclose(f);

    return true;
}

//-----------------------------------------------------------------------------
// Loading resources, on Windows.
//-----------------------------------------------------------------------------

#if defined(WIN32) &amp;&amp; !defined(LIBRARY)

</t>
<t tx="leo.20171226104022.112">const void *LoadResource(const std::string &amp;name, size_t *size) {
    HRSRC hres = FindResourceW(NULL, Widen(name).c_str(), RT_RCDATA);
    ssassert(hres != NULL, "Cannot find resource");
    HGLOBAL res = ::LoadResource(NULL, hres);
    ssassert(res != NULL, "Cannot load resource");

    *size = SizeofResource(NULL, hres);
    return LockResource(res);
}

#endif

//-----------------------------------------------------------------------------
// Loading resources, on *nix.
//-----------------------------------------------------------------------------

#if defined(__APPLE__)

</t>
<t tx="leo.20171226104022.113">static Platform::Path PathFromCFURL(CFURLRef cfUrl) {
    Path path;
    CFStringRef cfPath = CFURLCopyFileSystemPath(cfUrl, kCFURLPOSIXPathStyle);
    path.raw.resize(CFStringGetMaximumSizeOfFileSystemRepresentation(cfPath));
    CFStringGetFileSystemRepresentation(cfPath, &amp;path.raw[0], path.raw.size());
    path.raw.erase(path.raw.find('\0'));
    CFRelease(cfPath);
    return path;
}

</t>
<t tx="leo.20171226104022.114">static Platform::Path ResourcePath(const std::string &amp;name) {
    Path path;

    // First, try to get the URL from the bundle.
    CFStringRef cfName = CFStringCreateWithCString(kCFAllocatorDefault, name.c_str(),
                                                   kCFStringEncodingUTF8);
    CFURLRef cfUrl = CFBundleCopyResourceURL(CFBundleGetMainBundle(), cfName, NULL, NULL);
    if(cfUrl != NULL) {
        path = PathFromCFURL(cfUrl);
        CFRelease(cfUrl);
    }
    CFRelease(cfName);

    if(!path.IsEmpty()) return path;

    // If that failed, it means we aren't running from the bundle.
    // Reference off the executable path, then.
    cfUrl = CFBundleCopyExecutableURL(CFBundleGetMainBundle());
    if(cfUrl != NULL) {
        path = PathFromCFURL(cfUrl).Parent().Parent().Join("res");
        path = path.Join(Path::FromPortable(name));
        CFRelease(cfUrl);
    }

    return path;
}

#elif !defined(WIN32)

#    if defined(__linux__)
static const char *selfSymlink = "/proc/self/exe";
#    elif defined(__NetBSD__)
static const char *selfSymlink = "/proc/curproc/exe";
#    elif defined(__OpenBSD__) || defined(__FreeBSD__)
static const char *selfSymlink = "/proc/curproc/file";
#    else
static const char *selfSymlink = "";
#    endif

</t>
<t tx="leo.20171226104022.115">static Platform::Path FindLocalResourceDir() {
    // Find out the path to the running binary.
    Platform::Path selfPath;
    char *expandedSelfPath = realpath(selfSymlink, NULL);
    if(expandedSelfPath != NULL) {
        selfPath = Path::From(expandedSelfPath);
    }
    free(expandedSelfPath);

    Platform::Path resourceDir;
    if(selfPath.IsEmpty()) {
        // We don't know how to find the local resource directory on this platform,
        // so use the global one (by returning an empty string).
        return Path::From(UNIX_DATADIR);
    } else {
        resourceDir = selfPath.Parent().Parent().Join("res");
    }

    struct stat st;
    if(stat(resourceDir.raw.c_str(), &amp;st) != -1) {
        // An executable-adjacent resource directory exists, good.
        return resourceDir;
    }

    // No executable-adjacent resource directory; use the one from compile-time prefix.
    return Path::From(UNIX_DATADIR);
}

</t>
<t tx="leo.20171226104022.116">static Platform::Path ResourcePath(const std::string &amp;name) {
    static Platform::Path resourceDir;
    if(resourceDir.IsEmpty()) {
        resourceDir = FindLocalResourceDir();
    }

    return resourceDir.Join(Path::FromPortable(name));
}

#endif

#if !defined(WIN32)

</t>
<t tx="leo.20171226104022.117">const void *LoadResource(const std::string &amp;name, size_t *size) {
    static std::map&lt;std::string, std::string&gt; cache;

    auto it = cache.find(name);
    if(it == cache.end()) {
        ssassert(ReadFile(ResourcePath(name), &amp;cache[name]), "Cannot read resource");
        it = cache.find(name);
    }

    const std::string &amp;content = (*it).second;
    *size = content.size();
    return (const void*)content.data();
}

#endif

}
}
</t>
<t tx="leo.20171226104022.118">//-----------------------------------------------------------------------------
// Utility functions used by the Unix port. Notably, our memory allocation;
// we use two separate allocators, one for long-lived stuff and one for
// stuff that gets freed after every regeneration of the model, to save us
// the trouble of freeing the latter explicitly.
//
// Copyright 2008-2013 Jonathan Westhues.
// Copyright 2013 Daniel Richard G. &lt;skunk@iSKUNK.ORG&gt;
//-----------------------------------------------------------------------------
#include &lt;execinfo.h&gt;
#include "solvespace.h"

namespace SolveSpace {

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20171226104022.119">void dbp(const char *str, ...)
{
    va_list f;
    static char buf[1024*50];
    va_start(f, str);
    vsnprintf(buf, sizeof(buf), str, f);
    va_end(f);

    fputs(buf, stderr);
    fputc('\n', stderr);
}

</t>
<t tx="leo.20171226104022.12">void ConstraintBase::Generate(IdList&lt;Param,hParam&gt; *l) {
    switch(type) {
        case Type::PARALLEL:
        case Type::CUBIC_LINE_TANGENT:
            // Add new parameter only when we operate in 3d space
            if(workplane.v != EntityBase::FREE_IN_3D.v) break;
            // fallthrough
        case Type::SAME_ORIENTATION:
        case Type::PT_ON_LINE: {
            Param p = {};
            valP = h.param(0);
            p.h = valP;
            l-&gt;Add(&amp;p);
            break;
        }

        default:
            break;
    }
}

</t>
<t tx="leo.20171226104022.120">void assert_failure(const char *file, unsigned line, const char *function,
                    const char *condition, const char *message) {
    fprintf(stderr, "File %s, line %u, function %s:\n", file, line, function);
    fprintf(stderr, "Assertion '%s' failed: ((%s) == false).\n", message, condition);

#ifndef LIBRARY
    static void *ptrs[1024] = {};
    size_t nptrs = backtrace(ptrs, sizeof(ptrs) / sizeof(ptrs[0]));
    char **syms = backtrace_symbols(ptrs, nptrs);

    fprintf(stderr, "Backtrace:\n");
    if(syms != NULL) {
        for(size_t i = 0; i &lt; nptrs; i++) {
            fprintf(stderr, "%2zu: %s\n", i, syms[i]);
        }
    } else {
        for(size_t i = 0; i &lt; nptrs; i++) {
            fprintf(stderr, "%2zu: %p\n", i, ptrs[i]);
        }
    }
#endif

    abort();
}

//-----------------------------------------------------------------------------
// A separate heap, on which we allocate expressions. Maybe a bit faster,
// since fragmentation is less of a concern, and it also makes it possible
// to be sloppy with our memory management, and just free everything at once
// at the end.
//-----------------------------------------------------------------------------

typedef struct _AllocTempHeader AllocTempHeader;

</t>
<t tx="leo.20171226104022.121">typedef struct _AllocTempHeader {
    AllocTempHeader *prev;
    AllocTempHeader *next;
} AllocTempHeader;

static AllocTempHeader *Head = NULL;

</t>
<t tx="leo.20171226104022.122">void *AllocTemporary(size_t n)
{
    AllocTempHeader *h =
        (AllocTempHeader *)malloc(n + sizeof(AllocTempHeader));
    h-&gt;prev = NULL;
    h-&gt;next = Head;
    if(Head) Head-&gt;prev = h;
    Head = h;
    memset(&amp;h[1], 0, n);
    return (void *)&amp;h[1];
}

</t>
<t tx="leo.20171226104022.123">void FreeTemporary(void *p)
{
    AllocTempHeader *h = (AllocTempHeader *)p - 1;
    if(h-&gt;prev) {
        h-&gt;prev-&gt;next = h-&gt;next;
    } else {
        Head = h-&gt;next;
    }
    if(h-&gt;next) h-&gt;next-&gt;prev = h-&gt;prev;
    free(h);
}

</t>
<t tx="leo.20171226104022.124">void FreeAllTemporary(void)
{
    AllocTempHeader *h = Head;
    while(h) {
        AllocTempHeader *f = h;
        h = h-&gt;next;
        free(f);
    }
    Head = NULL;
}

</t>
<t tx="leo.20171226104022.125">void *MemAlloc(size_t n) {
    void *p = malloc(n);
    ssassert(p != NULL, "Cannot allocate memory");
    return p;
}

</t>
<t tx="leo.20171226104022.126">void MemFree(void *p) {
    free(p);
}

std::vector&lt;std::string&gt; InitPlatform(int argc, char **argv) {
    std::vector&lt;std::string&gt; args;
    for(int i = 0; i &lt; argc; i++) {
        args.push_back(argv[i]);
    }
    return args;
}

};
</t>
<t tx="leo.20171226104022.127">//-----------------------------------------------------------------------------
// Utility functions that depend on Win32. Notably, our memory allocation;
// we use two separate allocators, one for long-lived stuff and one for
// stuff that gets freed after every regeneration of the model, to save us
// the trouble of freeing the latter explicitly.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

// Include after solvespace.h to avoid identifier clashes.
#include &lt;windows.h&gt;
#include &lt;shellapi.h&gt;

namespace SolveSpace {
static HANDLE PermHeap, TempHeap;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20171226104022.128">void dbp(const char *str, ...)
{
    va_list f;
    static char buf[1024*50];
    va_start(f, str);
    _vsnprintf(buf, sizeof(buf), str, f);
    va_end(f);

    // The native version of OutputDebugString, unlike most others,
    // is OutputDebugStringA.
    OutputDebugStringA(buf);
    OutputDebugStringA("\n");

#ifndef NDEBUG
    // Duplicate to stderr in debug builds, but not in release; this is slow.
    fputs(buf, stderr);
    fputc('\n', stderr);
#endif
}

</t>
<t tx="leo.20171226104022.129">void assert_failure(const char *file, unsigned line, const char *function,
                    const char *condition, const char *message) {
    dbp("File %s, line %u, function %s:", file, line, function);
    dbp("Assertion '%s' failed: ((%s) == false).", message, condition);
#ifdef NDEBUG
    _exit(1);
#else
    abort();
#endif
}

//-----------------------------------------------------------------------------
// A separate heap, on which we allocate expressions. Maybe a bit faster,
// since no fragmentation issues whatsoever, and it also makes it possible
// to be sloppy with our memory management, and just free everything at once
// at the end.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20171226104022.13">void ConstraintBase::GenerateEquations(IdList&lt;Equation,hEquation&gt; *l,
                                       bool forReference) const {
    if(reference &amp;&amp; !forReference) return;

    Expr *exA = Expr::From(valA);
    switch(type) {
        case Type::PT_PT_DISTANCE:
            AddEq(l, Distance(workplane, ptA, ptB)-&gt;Minus(exA), 0);
            return;

        case Type::PROJ_PT_DISTANCE: {
            ExprVector pA = SK.GetEntity(ptA)-&gt;PointGetExprs(),
                       pB = SK.GetEntity(ptB)-&gt;PointGetExprs(),
                       dp = pB.Minus(pA);

            ExprVector pp = SK.GetEntity(entityA)-&gt;VectorGetExprs();
            pp = pp.WithMagnitude(Expr::From(1.0));

            AddEq(l, (dp.Dot(pp))-&gt;Minus(exA), 0);
            return;
        }

        case Type::PT_LINE_DISTANCE:
            AddEq(l,
                PointLineDistance(workplane, ptA, entityA)-&gt;Minus(exA), 0);
            return;

        case Type::PT_PLANE_DISTANCE: {
            ExprVector pt = SK.GetEntity(ptA)-&gt;PointGetExprs();
            AddEq(l, (PointPlaneDistance(pt, entityA))-&gt;Minus(exA), 0);
            return;
        }

        case Type::PT_FACE_DISTANCE: {
            ExprVector pt = SK.GetEntity(ptA)-&gt;PointGetExprs();
            EntityBase *f = SK.GetEntity(entityA);
            ExprVector p0 = f-&gt;FaceGetPointExprs();
            ExprVector n = f-&gt;FaceGetNormalExprs();
            AddEq(l, (pt.Minus(p0)).Dot(n)-&gt;Minus(exA), 0);
            return;
        }

        case Type::EQUAL_LENGTH_LINES: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);
            AddEq(l, Distance(workplane, a-&gt;point[0], a-&gt;point[1])-&gt;Minus(
                     Distance(workplane, b-&gt;point[0], b-&gt;point[1])), 0);
            return;
        }

        // These work on distance squared, since the pt-line distances are
        // signed, and we want the absolute value.
        case Type::EQ_LEN_PT_LINE_D: {
            EntityBase *forLen = SK.GetEntity(entityA);
            Expr *d1 = Distance(workplane, forLen-&gt;point[0], forLen-&gt;point[1]);
            Expr *d2 = PointLineDistance(workplane, ptA, entityB);
            AddEq(l, (d1-&gt;Square())-&gt;Minus(d2-&gt;Square()), 0);
            return;
        }
        case Type::EQ_PT_LN_DISTANCES: {
            Expr *d1 = PointLineDistance(workplane, ptA, entityA);
            Expr *d2 = PointLineDistance(workplane, ptB, entityB);
            AddEq(l, (d1-&gt;Square())-&gt;Minus(d2-&gt;Square()), 0);
            return;
        }

        case Type::LENGTH_RATIO: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);
            Expr *la = Distance(workplane, a-&gt;point[0], a-&gt;point[1]);
            Expr *lb = Distance(workplane, b-&gt;point[0], b-&gt;point[1]);
            AddEq(l, (la-&gt;Div(lb))-&gt;Minus(exA), 0);
            return;
        }

        case Type::LENGTH_DIFFERENCE: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);
            Expr *la = Distance(workplane, a-&gt;point[0], a-&gt;point[1]);
            Expr *lb = Distance(workplane, b-&gt;point[0], b-&gt;point[1]);
            AddEq(l, (la-&gt;Minus(lb))-&gt;Minus(exA), 0);
            return;
        }

        case Type::DIAMETER: {
            EntityBase *circle = SK.GetEntity(entityA);
            Expr *r = circle-&gt;CircleGetRadiusExpr();
            AddEq(l, (r-&gt;Times(Expr::From(2)))-&gt;Minus(exA), 0);
            return;
        }

        case Type::EQUAL_RADIUS: {
            EntityBase *c1 = SK.GetEntity(entityA);
            EntityBase *c2 = SK.GetEntity(entityB);
            AddEq(l, (c1-&gt;CircleGetRadiusExpr())-&gt;Minus(
                      c2-&gt;CircleGetRadiusExpr()), 0);
            return;
        }

        case Type::EQUAL_LINE_ARC_LEN: {
            EntityBase *line = SK.GetEntity(entityA),
                       *arc  = SK.GetEntity(entityB);

            // Get the line length
            ExprVector l0 = SK.GetEntity(line-&gt;point[0])-&gt;PointGetExprs(),
                       l1 = SK.GetEntity(line-&gt;point[1])-&gt;PointGetExprs();
            Expr *ll = (l1.Minus(l0)).Magnitude();

            // And get the arc radius, and the cosine of its angle
            EntityBase *ao = SK.GetEntity(arc-&gt;point[0]),
                       *as = SK.GetEntity(arc-&gt;point[1]),
                       *af = SK.GetEntity(arc-&gt;point[2]);

            ExprVector aos = (as-&gt;PointGetExprs()).Minus(ao-&gt;PointGetExprs()),
                       aof = (af-&gt;PointGetExprs()).Minus(ao-&gt;PointGetExprs());
            Expr *r = aof.Magnitude();

            ExprVector n = arc-&gt;Normal()-&gt;NormalExprsN();
            ExprVector u = aos.WithMagnitude(Expr::From(1.0));
            ExprVector v = n.Cross(u);
            // so in our new csys, we start at (1, 0, 0)
            Expr *costheta = aof.Dot(u)-&gt;Div(r);
            Expr *sintheta = aof.Dot(v)-&gt;Div(r);

            double thetas, thetaf, dtheta;
            arc-&gt;ArcGetAngles(&amp;thetas, &amp;thetaf, &amp;dtheta);
            Expr *theta;
            if(dtheta &lt; 3*PI/4) {
                theta = costheta-&gt;ACos();
            } else if(dtheta &lt; 5*PI/4) {
                // As the angle crosses pi, cos theta is not invertible;
                // so use the sine to stop blowing up
                theta = Expr::From(PI)-&gt;Minus(sintheta-&gt;ASin());
            } else {
                theta = (Expr::From(2*PI))-&gt;Minus(costheta-&gt;ACos());
            }

            // And write the equation; r*theta = L
            AddEq(l, (r-&gt;Times(theta))-&gt;Minus(ll), 0);
            return;
        }

        case Type::POINTS_COINCIDENT: {
            EntityBase *a = SK.GetEntity(ptA);
            EntityBase *b = SK.GetEntity(ptB);
            if(workplane.v == EntityBase::FREE_IN_3D.v) {
                ExprVector pa = a-&gt;PointGetExprs();
                ExprVector pb = b-&gt;PointGetExprs();
                AddEq(l, pa.x-&gt;Minus(pb.x), 0);
                AddEq(l, pa.y-&gt;Minus(pb.y), 1);
                AddEq(l, pa.z-&gt;Minus(pb.z), 2);
            } else {
                Expr *au, *av;
                Expr *bu, *bv;
                a-&gt;PointGetExprsInWorkplane(workplane, &amp;au, &amp;av);
                b-&gt;PointGetExprsInWorkplane(workplane, &amp;bu, &amp;bv);
                AddEq(l, au-&gt;Minus(bu), 0);
                AddEq(l, av-&gt;Minus(bv), 1);
            }
            return;
        }

        case Type::PT_IN_PLANE:
            // This one works the same, whether projected or not.
            AddEq(l, PointPlaneDistance(
                        SK.GetEntity(ptA)-&gt;PointGetExprs(), entityA), 0);
            return;

        case Type::PT_ON_FACE: {
            // a plane, n dot (p - p0) = 0
            ExprVector p = SK.GetEntity(ptA)-&gt;PointGetExprs();
            EntityBase *f = SK.GetEntity(entityA);
            ExprVector p0 = f-&gt;FaceGetPointExprs();
            ExprVector n = f-&gt;FaceGetNormalExprs();
            AddEq(l, (p.Minus(p0)).Dot(n), 0);
            return;
        }

        case Type::PT_ON_LINE: {
            EntityBase *ln = SK.GetEntity(entityA);
            EntityBase *a = SK.GetEntity(ln-&gt;point[0]);
            EntityBase *b = SK.GetEntity(ln-&gt;point[1]);
            EntityBase *p = SK.GetEntity(ptA);

            ExprVector ep = p-&gt;PointGetExprsInWorkplane(workplane);
            ExprVector ea = a-&gt;PointGetExprsInWorkplane(workplane);
            ExprVector eb = b-&gt;PointGetExprsInWorkplane(workplane);

            ExprVector ptOnLine = ea.Plus(eb.Minus(ea).ScaledBy(Expr::From(valP)));
            ExprVector eq = ptOnLine.Minus(ep);

            AddEq(l, eq);
            return;
        }

        case Type::PT_ON_CIRCLE: {
            // This actually constrains the point to lie on the cylinder.
            EntityBase *circle = SK.GetEntity(entityA);
            ExprVector center = SK.GetEntity(circle-&gt;point[0])-&gt;PointGetExprs();
            ExprVector pt     = SK.GetEntity(ptA)-&gt;PointGetExprs();
            EntityBase *normal = SK.GetEntity(circle-&gt;normal);
            ExprVector u = normal-&gt;NormalExprsU(),
                       v = normal-&gt;NormalExprsV();

            Expr *du = (center.Minus(pt)).Dot(u),
                 *dv = (center.Minus(pt)).Dot(v);

            Expr *r = circle-&gt;CircleGetRadiusExpr();

            AddEq(l, du-&gt;Square()-&gt;Plus(dv-&gt;Square())-&gt;Sqrt()-&gt;Minus(r), 0);
            return;
        }

        case Type::AT_MIDPOINT:
            if(workplane.v == EntityBase::FREE_IN_3D.v) {
                EntityBase *ln = SK.GetEntity(entityA);
                ExprVector a = SK.GetEntity(ln-&gt;point[0])-&gt;PointGetExprs();
                ExprVector b = SK.GetEntity(ln-&gt;point[1])-&gt;PointGetExprs();
                ExprVector m = (a.Plus(b)).ScaledBy(Expr::From(0.5));

                if(ptA.v) {
                    ExprVector p = SK.GetEntity(ptA)-&gt;PointGetExprs();
                    AddEq(l, (m.x)-&gt;Minus(p.x), 0);
                    AddEq(l, (m.y)-&gt;Minus(p.y), 1);
                    AddEq(l, (m.z)-&gt;Minus(p.z), 2);
                } else {
                    AddEq(l, PointPlaneDistance(m, entityB), 0);
                }
            } else {
                EntityBase *ln = SK.GetEntity(entityA);
                EntityBase *a = SK.GetEntity(ln-&gt;point[0]);
                EntityBase *b = SK.GetEntity(ln-&gt;point[1]);

                Expr *au, *av, *bu, *bv;
                a-&gt;PointGetExprsInWorkplane(workplane, &amp;au, &amp;av);
                b-&gt;PointGetExprsInWorkplane(workplane, &amp;bu, &amp;bv);
                Expr *mu = Expr::From(0.5)-&gt;Times(au-&gt;Plus(bu));
                Expr *mv = Expr::From(0.5)-&gt;Times(av-&gt;Plus(bv));

                if(ptA.v) {
                    EntityBase *p = SK.GetEntity(ptA);
                    Expr *pu, *pv;
                    p-&gt;PointGetExprsInWorkplane(workplane, &amp;pu, &amp;pv);
                    AddEq(l, pu-&gt;Minus(mu), 0);
                    AddEq(l, pv-&gt;Minus(mv), 1);
                } else {
                    ExprVector m = PointInThreeSpace(workplane, mu, mv);
                    AddEq(l, PointPlaneDistance(m, entityB), 0);
                }
            }
            return;

        case Type::SYMMETRIC:
            if(workplane.v == EntityBase::FREE_IN_3D.v) {
                EntityBase *plane = SK.GetEntity(entityA);
                EntityBase *ea = SK.GetEntity(ptA);
                EntityBase *eb = SK.GetEntity(ptB);
                ExprVector a = ea-&gt;PointGetExprs();
                ExprVector b = eb-&gt;PointGetExprs();

                // The midpoint of the line connecting the symmetric points
                // lies on the plane of the symmetry.
                ExprVector m = (a.Plus(b)).ScaledBy(Expr::From(0.5));
                AddEq(l, PointPlaneDistance(m, plane-&gt;h), 0);

                // And projected into the plane of symmetry, the points are
                // coincident.
                Expr *au, *av, *bu, *bv;
                ea-&gt;PointGetExprsInWorkplane(plane-&gt;h, &amp;au, &amp;av);
                eb-&gt;PointGetExprsInWorkplane(plane-&gt;h, &amp;bu, &amp;bv);
                AddEq(l, au-&gt;Minus(bu), 1);
                AddEq(l, av-&gt;Minus(bv), 2);
            } else {
                EntityBase *plane = SK.GetEntity(entityA);
                EntityBase *a = SK.GetEntity(ptA);
                EntityBase *b = SK.GetEntity(ptB);

                Expr *au, *av, *bu, *bv;
                a-&gt;PointGetExprsInWorkplane(workplane, &amp;au, &amp;av);
                b-&gt;PointGetExprsInWorkplane(workplane, &amp;bu, &amp;bv);
                Expr *mu = Expr::From(0.5)-&gt;Times(au-&gt;Plus(bu));
                Expr *mv = Expr::From(0.5)-&gt;Times(av-&gt;Plus(bv));

                ExprVector m = PointInThreeSpace(workplane, mu, mv);
                AddEq(l, PointPlaneDistance(m, plane-&gt;h), 0);

                // Construct a vector within the workplane that is normal
                // to the symmetry pane's normal (i.e., that lies in the
                // plane of symmetry). The line connecting the points is
                // perpendicular to that constructed vector.
                EntityBase *w = SK.GetEntity(workplane);
                ExprVector u = w-&gt;Normal()-&gt;NormalExprsU();
                ExprVector v = w-&gt;Normal()-&gt;NormalExprsV();

                ExprVector pa = a-&gt;PointGetExprs();
                ExprVector pb = b-&gt;PointGetExprs();
                ExprVector n;
                Expr *d;
                plane-&gt;WorkplaneGetPlaneExprs(&amp;n, &amp;d);
                AddEq(l, (n.Cross(u.Cross(v))).Dot(pa.Minus(pb)), 1);
            }
            return;

        case Type::SYMMETRIC_HORIZ:
        case Type::SYMMETRIC_VERT: {
            ssassert(workplane.v != Entity::FREE_IN_3D.v,
                     "Unexpected horizontal/vertical symmetric constraint in 3d");

            EntityBase *a = SK.GetEntity(ptA);
            EntityBase *b = SK.GetEntity(ptB);

            Expr *au, *av, *bu, *bv;
            a-&gt;PointGetExprsInWorkplane(workplane, &amp;au, &amp;av);
            b-&gt;PointGetExprsInWorkplane(workplane, &amp;bu, &amp;bv);

            if(type == Type::SYMMETRIC_HORIZ) {
                AddEq(l, av-&gt;Minus(bv), 0);
                AddEq(l, au-&gt;Plus(bu), 1);
            } else {
                AddEq(l, au-&gt;Minus(bu), 0);
                AddEq(l, av-&gt;Plus(bv), 1);
            }
            return;
        }

        case Type::SYMMETRIC_LINE: {
            EntityBase *pa = SK.GetEntity(ptA);
            EntityBase *pb = SK.GetEntity(ptB);

            Expr *pau, *pav, *pbu, *pbv;
            pa-&gt;PointGetExprsInWorkplane(workplane, &amp;pau, &amp;pav);
            pb-&gt;PointGetExprsInWorkplane(workplane, &amp;pbu, &amp;pbv);

            EntityBase *ln = SK.GetEntity(entityA);
            EntityBase *la = SK.GetEntity(ln-&gt;point[0]);
            EntityBase *lb = SK.GetEntity(ln-&gt;point[1]);
            Expr *lau, *lav, *lbu, *lbv;
            la-&gt;PointGetExprsInWorkplane(workplane, &amp;lau, &amp;lav);
            lb-&gt;PointGetExprsInWorkplane(workplane, &amp;lbu, &amp;lbv);

            Expr *dpu = pbu-&gt;Minus(pau), *dpv = pbv-&gt;Minus(pav);
            Expr *dlu = lbu-&gt;Minus(lau), *dlv = lbv-&gt;Minus(lav);

            // The line through the points is perpendicular to the line
            // of symmetry.
            AddEq(l, (dlu-&gt;Times(dpu))-&gt;Plus(dlv-&gt;Times(dpv)), 0);

            // And the signed distances of the points to the line are
            // equal in magnitude and opposite in sign, so sum to zero
            Expr *dista = (dlv-&gt;Times(lau-&gt;Minus(pau)))-&gt;Minus(
                          (dlu-&gt;Times(lav-&gt;Minus(pav))));
            Expr *distb = (dlv-&gt;Times(lau-&gt;Minus(pbu)))-&gt;Minus(
                          (dlu-&gt;Times(lav-&gt;Minus(pbv))));
            AddEq(l, dista-&gt;Plus(distb), 1);

            return;
        }

        case Type::HORIZONTAL:
        case Type::VERTICAL: {
            ssassert(workplane.v != Entity::FREE_IN_3D.v,
                     "Unexpected horizontal/vertical constraint in 3d");

            hEntity ha, hb;
            if(entityA.v) {
                EntityBase *e = SK.GetEntity(entityA);
                ha = e-&gt;point[0];
                hb = e-&gt;point[1];
            } else {
                ha = ptA;
                hb = ptB;
            }
            EntityBase *a = SK.GetEntity(ha);
            EntityBase *b = SK.GetEntity(hb);

            Expr *au, *av, *bu, *bv;
            a-&gt;PointGetExprsInWorkplane(workplane, &amp;au, &amp;av);
            b-&gt;PointGetExprsInWorkplane(workplane, &amp;bu, &amp;bv);

            AddEq(l, (type == Type::HORIZONTAL) ? av-&gt;Minus(bv) : au-&gt;Minus(bu), 0);
            return;
        }

        case Type::SAME_ORIENTATION: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);

            ExprVector au = a-&gt;NormalExprsU(),
                       an = a-&gt;NormalExprsN();
            ExprVector bu = b-&gt;NormalExprsU(),
                       bv = b-&gt;NormalExprsV(),
                       bn = b-&gt;NormalExprsN();

            ExprVector eq = VectorsParallel3d(an, bn, valP);
            AddEq(l, eq.x, 0);
            AddEq(l, eq.y, 1);
            AddEq(l, eq.z, 2);
            Expr *d1 = au.Dot(bv);
            Expr *d2 = au.Dot(bu);
            // Allow either orientation for the coordinate system, depending
            // on how it was drawn.
            if(fabs(d1-&gt;Eval()) &lt; fabs(d2-&gt;Eval())) {
                AddEq(l, d1, 3);
            } else {
                AddEq(l, d2, 3);
            }
            return;
        }

        case Type::PERPENDICULAR:
        case Type::ANGLE: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);
            ExprVector ae = a-&gt;VectorGetExprs();
            ExprVector be = b-&gt;VectorGetExprs();
            if(other) ae = ae.ScaledBy(Expr::From(-1));
            Expr *c = DirectionCosine(workplane, ae, be);

            if(type == Type::ANGLE) {
                // The direction cosine is equal to the cosine of the
                // specified angle
                Expr *rads = exA-&gt;Times(Expr::From(PI/180)),
                     *rc   = rads-&gt;Cos();
                double arc = fabs(rc-&gt;Eval());
                // avoid false detection of inconsistent systems by gaining
                // up as the difference in dot products gets small at small
                // angles; doubles still have plenty of precision, only
                // problem is that rank test
                Expr *mult = Expr::From(arc &gt; 0.99 ? 0.01/(1.00001 - arc) : 1);
                AddEq(l, (c-&gt;Minus(rc))-&gt;Times(mult), 0);
            } else {
                // The dot product (and therefore the direction cosine)
                // is equal to zero, perpendicular.
                AddEq(l, c, 0);
            }
            return;
        }

        case Type::EQUAL_ANGLE: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);
            EntityBase *c = SK.GetEntity(entityC);
            EntityBase *d = SK.GetEntity(entityD);
            ExprVector ae = a-&gt;VectorGetExprs();
            ExprVector be = b-&gt;VectorGetExprs();
            ExprVector ce = c-&gt;VectorGetExprs();
            ExprVector de = d-&gt;VectorGetExprs();

            if(other) ae = ae.ScaledBy(Expr::From(-1));

            Expr *cab = DirectionCosine(workplane, ae, be);
            Expr *ccd = DirectionCosine(workplane, ce, de);

            AddEq(l, cab-&gt;Minus(ccd), 0);
            return;
        }

        case Type::ARC_LINE_TANGENT: {
            EntityBase *arc  = SK.GetEntity(entityA);
            EntityBase *line = SK.GetEntity(entityB);

            ExprVector ac = SK.GetEntity(arc-&gt;point[0])-&gt;PointGetExprs();
            ExprVector ap =
                SK.GetEntity(arc-&gt;point[other ? 2 : 1])-&gt;PointGetExprs();

            ExprVector ld = line-&gt;VectorGetExprs();

            // The line is perpendicular to the radius
            AddEq(l, ld.Dot(ac.Minus(ap)), 0);
            return;
        }

        case Type::CUBIC_LINE_TANGENT: {
            EntityBase *cubic = SK.GetEntity(entityA);
            EntityBase *line  = SK.GetEntity(entityB);

            ExprVector a;
            if(other) {
                a = cubic-&gt;CubicGetFinishTangentExprs();
            } else {
                a = cubic-&gt;CubicGetStartTangentExprs();
            }

            ExprVector b = line-&gt;VectorGetExprs();

            if(workplane.v == EntityBase::FREE_IN_3D.v) {
                ExprVector eq = VectorsParallel3d(a, b, valP);
                AddEq(l, eq);
            } else {
                EntityBase *w = SK.GetEntity(workplane);
                ExprVector wn = w-&gt;Normal()-&gt;NormalExprsN();
                AddEq(l, (a.Cross(b)).Dot(wn), 0);
            }
            return;
        }

        case Type::CURVE_CURVE_TANGENT: {
            bool parallel = true;
            int i;
            ExprVector dir[2];
            for(i = 0; i &lt; 2; i++) {
                EntityBase *e = SK.GetEntity((i == 0) ? entityA : entityB);
                bool oth = (i == 0) ? other : other2;

                if(e-&gt;type == Entity::Type::ARC_OF_CIRCLE) {
                    ExprVector center, endpoint;
                    center = SK.GetEntity(e-&gt;point[0])-&gt;PointGetExprs();
                    endpoint =
                        SK.GetEntity(e-&gt;point[oth ? 2 : 1])-&gt;PointGetExprs();
                    dir[i] = endpoint.Minus(center);
                    // We're using the vector from the center of the arc to
                    // an endpoint; so that's normal to the tangent, not
                    // parallel.
                    parallel = !parallel;
                } else if(e-&gt;type == Entity::Type::CUBIC) { // BRANCH_ALWAYS_TAKEN
                    if(oth) {
                        dir[i] = e-&gt;CubicGetFinishTangentExprs();
                    } else {
                        dir[i] = e-&gt;CubicGetStartTangentExprs();
                    }
                } else {
                    ssassert(false, "Unexpected entity types for CURVE_CURVE_TANGENT");
                }
            }
            if(parallel) {
                EntityBase *w = SK.GetEntity(workplane);
                ExprVector wn = w-&gt;Normal()-&gt;NormalExprsN();
                AddEq(l, ((dir[0]).Cross(dir[1])).Dot(wn), 0);
            } else {
                AddEq(l, (dir[0]).Dot(dir[1]), 0);
            }
            return;
        }

        case Type::PARALLEL: {
            EntityBase *ea = SK.GetEntity(entityA), *eb = SK.GetEntity(entityB);
            ExprVector a = ea-&gt;VectorGetExprsInWorkplane(workplane);
            ExprVector b = eb-&gt;VectorGetExprsInWorkplane(workplane);

            if(workplane.v == EntityBase::FREE_IN_3D.v) {
                ExprVector eq = VectorsParallel3d(a, b, valP);
                AddEq(l, eq);
            } else {
                // We use expressions written in workplane csys, so we can assume the workplane
                // normal is (0, 0, 1). We can write the equation as:
                //   Expr *eq = a.Cross(b).Dot(ExprVector::From(0.0, 0.0, 1.0));
                // but this will just result in elimination of x and y terms after dot product.
                // We can only use the z expression:
                //   Expr *eq = a.Cross(b).z;
                // but it's more efficient to write it in the terms of pseudo-scalar product:
                Expr *eq = (a.x-&gt;Times(b.y))-&gt;Minus(a.y-&gt;Times(b.x));
                AddEq(l, eq, 0);
            }

            return;
        }

        case Type::WHERE_DRAGGED: {
            EntityBase *ep = SK.GetEntity(ptA);
            if(workplane.v == EntityBase::FREE_IN_3D.v) {
                ExprVector ev = ep-&gt;PointGetExprs();
                Vector v = ep-&gt;PointGetNum();

                AddEq(l, ev.x-&gt;Minus(Expr::From(v.x)), 0);
                AddEq(l, ev.y-&gt;Minus(Expr::From(v.y)), 1);
                AddEq(l, ev.z-&gt;Minus(Expr::From(v.z)), 2);
            } else {
                Expr *u, *v;
                ep-&gt;PointGetExprsInWorkplane(workplane, &amp;u, &amp;v);
                AddEq(l, u-&gt;Minus(Expr::From(u-&gt;Eval())), 0);
                AddEq(l, v-&gt;Minus(Expr::From(v-&gt;Eval())), 1);
            }
            return;
        }

        case Type::COMMENT:
            return;
    }
    ssassert(false, "Unexpected constraint ID");
}

</t>
<t tx="leo.20171226104022.130">void *AllocTemporary(size_t n)
{
    void *v = HeapAlloc(TempHeap, HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY, n);
    ssassert(v != NULL, "Cannot allocate memory");
    return v;
}
</t>
<t tx="leo.20171226104022.131">void FreeTemporary(void *p) {
    HeapFree(TempHeap, HEAP_NO_SERIALIZE, p);
}
</t>
<t tx="leo.20171226104022.132">void FreeAllTemporary()
{
    if(TempHeap) HeapDestroy(TempHeap);
    TempHeap = HeapCreate(HEAP_NO_SERIALIZE, 1024*1024*20, 0);
    // This is a good place to validate, because it gets called fairly
    // often.
    vl();
}

</t>
<t tx="leo.20171226104022.133">void *MemAlloc(size_t n) {
    void *p = HeapAlloc(PermHeap, HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY, n);
    ssassert(p != NULL, "Cannot allocate memory");
    return p;
}
</t>
<t tx="leo.20171226104022.134">void MemFree(void *p) {
    HeapFree(PermHeap, HEAP_NO_SERIALIZE, p);
}

</t>
<t tx="leo.20171226104022.135">void vl() {
    ssassert(HeapValidate(TempHeap, HEAP_NO_SERIALIZE, NULL), "Corrupted heap");
    ssassert(HeapValidate(PermHeap, HEAP_NO_SERIALIZE, NULL), "Corrupted heap");
}

std::vector&lt;std::string&gt; InitPlatform(int argc, char **argv) {
    // Create the heap used for long-lived stuff (that gets freed piecewise).
    PermHeap = HeapCreate(HEAP_NO_SERIALIZE, 1024*1024*20, 0);
    // Create the heap that we use to store Exprs and other temp stuff.
    FreeAllTemporary();

#if !defined(LIBRARY) &amp;&amp; defined(_MSC_VER)
    // Don't display the abort message; it is aggravating in CLI binaries
    // and results in infinite WndProc recursion in GUI binaries.
    _set_abort_behavior(0, _WRITE_ABORT_MSG);
    int crtReportTypes[] = {_CRT_WARN, _CRT_ERROR, _CRT_ASSERT};
    for(int crtReportType : crtReportTypes) {
        _CrtSetReportMode(crtReportType, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
        _CrtSetReportFile(crtReportType, _CRTDBG_FILE_STDERR);
    }
#endif

    // Extract the command-line arguments; the ones from main() are ignored,
    // since they are in the OEM encoding.
    int argcW;
    LPWSTR *argvW = CommandLineToArgvW(GetCommandLineW(), &amp;argcW);
    std::vector&lt;std::string&gt; args;
    for(int i = 0; i &lt; argcW; i++) {
        args.push_back(Platform::Narrow(argvW[i]));
    }
    LocalFree(argvW);
    return args;
}

}
</t>
<t tx="leo.20171226104022.14">//-----------------------------------------------------------------------------
// The implementation of our entities in the symbolic algebra system, methods
// to return a symbolic representation of the entity (line by its endpoints,
// circle by center and radius, etc.).
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

const hEntity  EntityBase::FREE_IN_3D = { 0 };
const hEntity  EntityBase::NO_ENTITY = { 0 };

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20171226104022.15">bool EntityBase::HasVector() const {
    switch(type) {
        case Type::LINE_SEGMENT:
        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
            return true;

        default:
            return false;
    }
}

ExprVector EntityBase::VectorGetExprsInWorkplane(hEntity wrkpl) const {
    switch(type) {
        case Type::LINE_SEGMENT:
            return (SK.GetEntity(point[0])-&gt;PointGetExprsInWorkplane(wrkpl)).Minus(
                    SK.GetEntity(point[1])-&gt;PointGetExprsInWorkplane(wrkpl));

        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA: {
            ExprVector ev = NormalExprsN();
            if(wrkpl.v == EntityBase::FREE_IN_3D.v) {
                return ev;
            }
            // Get the offset and basis vectors for this weird exotic csys.
            EntityBase *w = SK.GetEntity(wrkpl);
            ExprVector wu = w-&gt;Normal()-&gt;NormalExprsU();
            ExprVector wv = w-&gt;Normal()-&gt;NormalExprsV();

            // Get our coordinates in three-space, and project them into that
            // coordinate system.
            ExprVector result;
            result.x = ev.Dot(wu);
            result.y = ev.Dot(wv);
            result.z = Expr::From(0.0);
            return result;
        }
        default: ssassert(false, "Unexpected entity type");
    }
}

ExprVector EntityBase::VectorGetExprs() const {
    return VectorGetExprsInWorkplane(EntityBase::FREE_IN_3D);
}

Vector EntityBase::VectorGetNum() const {
    switch(type) {
        case Type::LINE_SEGMENT:
            return (SK.GetEntity(point[0])-&gt;PointGetNum()).Minus(
                    SK.GetEntity(point[1])-&gt;PointGetNum());

        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
            return NormalN();

        default: ssassert(false, "Unexpected entity type");
    }
}

Vector EntityBase::VectorGetRefPoint() const {
    switch(type) {
        case Type::LINE_SEGMENT:
            return ((SK.GetEntity(point[0])-&gt;PointGetNum()).Plus(
                     SK.GetEntity(point[1])-&gt;PointGetNum())).ScaledBy(0.5);

        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
            return SK.GetEntity(point[0])-&gt;PointGetNum();

        default: ssassert(false, "Unexpected entity type");
    }
}

Vector EntityBase::VectorGetStartPoint() const {
    switch(type) {
        case Type::LINE_SEGMENT:
            return SK.GetEntity(point[1])-&gt;PointGetNum();

        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
            return SK.GetEntity(point[0])-&gt;PointGetNum();

        default: ssassert(false, "Unexpected entity type");
    }
}

</t>
<t tx="leo.20171226104022.16">bool EntityBase::IsCircle() const {
    return (type == Type::CIRCLE) || (type == Type::ARC_OF_CIRCLE);
}

Expr *EntityBase::CircleGetRadiusExpr() const {
    if(type == Type::CIRCLE) {
        return SK.GetEntity(distance)-&gt;DistanceGetExpr();
    } else if(type == Type::ARC_OF_CIRCLE) {
        return Constraint::Distance(workplane, point[0], point[1]);
    } else ssassert(false, "Unexpected entity type");
}

double EntityBase::CircleGetRadiusNum() const {
    if(type == Type::CIRCLE) {
        return SK.GetEntity(distance)-&gt;DistanceGetNum();
    } else if(type == Type::ARC_OF_CIRCLE) {
        Vector c  = SK.GetEntity(point[0])-&gt;PointGetNum();
        Vector pa = SK.GetEntity(point[1])-&gt;PointGetNum();
        return (pa.Minus(c)).Magnitude();
    } else ssassert(false, "Unexpected entity type");
}

</t>
<t tx="leo.20171226104022.17">void EntityBase::ArcGetAngles(double *thetaa, double *thetab, double *dtheta) const {
    ssassert(type == Type::ARC_OF_CIRCLE, "Unexpected entity type");

    Quaternion q = Normal()-&gt;NormalGetNum();
    Vector u = q.RotationU(), v = q.RotationV();

    Vector c  = SK.GetEntity(point[0])-&gt;PointGetNum();
    Vector pa = SK.GetEntity(point[1])-&gt;PointGetNum();
    Vector pb = SK.GetEntity(point[2])-&gt;PointGetNum();

    Point2d c2  = c.Project2d(u, v);
    Point2d pa2 = (pa.Project2d(u, v)).Minus(c2);
    Point2d pb2 = (pb.Project2d(u, v)).Minus(c2);

    *thetaa = atan2(pa2.y, pa2.x);
    *thetab = atan2(pb2.y, pb2.x);
    *dtheta = *thetab - *thetaa;
    // If the endpoints are coincident, call it a full arc, not a zero arc;
    // useful concept to have when splitting
    while(*dtheta &lt; 1e-6) *dtheta += 2*PI;
    while(*dtheta &gt; (2*PI)) *dtheta -= 2*PI;
}

Vector EntityBase::CubicGetStartNum() const {
    return SK.GetEntity(point[0])-&gt;PointGetNum();
}
Vector EntityBase::CubicGetFinishNum() const {
    return SK.GetEntity(point[3+extraPoints])-&gt;PointGetNum();
}
ExprVector EntityBase::CubicGetStartTangentExprs() const {
    ExprVector pon  = SK.GetEntity(point[0])-&gt;PointGetExprs(),
               poff = SK.GetEntity(point[1])-&gt;PointGetExprs();
    return (pon.Minus(poff));
}
ExprVector EntityBase::CubicGetFinishTangentExprs() const {
    ExprVector pon  = SK.GetEntity(point[3+extraPoints])-&gt;PointGetExprs(),
               poff = SK.GetEntity(point[2+extraPoints])-&gt;PointGetExprs();
    return (pon.Minus(poff));
}
Vector EntityBase::CubicGetStartTangentNum() const {
    Vector pon  = SK.GetEntity(point[0])-&gt;PointGetNum(),
           poff = SK.GetEntity(point[1])-&gt;PointGetNum();
    return (pon.Minus(poff));
}
Vector EntityBase::CubicGetFinishTangentNum() const {
    Vector pon  = SK.GetEntity(point[3+extraPoints])-&gt;PointGetNum(),
           poff = SK.GetEntity(point[2+extraPoints])-&gt;PointGetNum();
    return (pon.Minus(poff));
}

</t>
<t tx="leo.20171226104022.18">bool EntityBase::IsWorkplane() const {
    return (type == Type::WORKPLANE);
}

ExprVector EntityBase::WorkplaneGetOffsetExprs() const {
    return SK.GetEntity(point[0])-&gt;PointGetExprs();
}

Vector EntityBase::WorkplaneGetOffset() const {
    return SK.GetEntity(point[0])-&gt;PointGetNum();
}

</t>
<t tx="leo.20171226104022.19">void EntityBase::WorkplaneGetPlaneExprs(ExprVector *n, Expr **dn) const {
    if(type == Type::WORKPLANE) {
        *n = Normal()-&gt;NormalExprsN();

        ExprVector p0 = SK.GetEntity(point[0])-&gt;PointGetExprs();
        // The plane is n dot (p - p0) = 0, or
        //              n dot p - n dot p0 = 0
        // so dn = n dot p0
        *dn = p0.Dot(*n);
    } else ssassert(false, "Unexpected entity type");
}

</t>
<t tx="leo.20171226104022.2">//-----------------------------------------------------------------------------
// Implementation of the Constraint menu, to create new constraints in
// the sketch.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

std::string Constraint::DescriptionString() const {
    std::string s;
    switch(type) {
        case Type::POINTS_COINCIDENT:   s = C_("constr-name", "pts-coincident"); break;
        case Type::PT_PT_DISTANCE:      s = C_("constr-name", "pt-pt-distance"); break;
        case Type::PT_LINE_DISTANCE:    s = C_("constr-name", "pt-line-distance"); break;
        case Type::PT_PLANE_DISTANCE:   s = C_("constr-name", "pt-plane-distance"); break;
        case Type::PT_FACE_DISTANCE:    s = C_("constr-name", "pt-face-distance"); break;
        case Type::PROJ_PT_DISTANCE:    s = C_("constr-name", "proj-pt-pt-distance"); break;
        case Type::PT_IN_PLANE:         s = C_("constr-name", "pt-in-plane"); break;
        case Type::PT_ON_LINE:          s = C_("constr-name", "pt-on-line"); break;
        case Type::PT_ON_FACE:          s = C_("constr-name", "pt-on-face"); break;
        case Type::EQUAL_LENGTH_LINES:  s = C_("constr-name", "eq-length"); break;
        case Type::EQ_LEN_PT_LINE_D:    s = C_("constr-name", "eq-length-and-pt-ln-dist"); break;
        case Type::EQ_PT_LN_DISTANCES:  s = C_("constr-name", "eq-pt-line-distances"); break;
        case Type::LENGTH_RATIO:        s = C_("constr-name", "length-ratio"); break;
        case Type::LENGTH_DIFFERENCE:   s = C_("constr-name", "length-difference"); break;
        case Type::SYMMETRIC:           s = C_("constr-name", "symmetric"); break;
        case Type::SYMMETRIC_HORIZ:     s = C_("constr-name", "symmetric-h"); break;
        case Type::SYMMETRIC_VERT:      s = C_("constr-name", "symmetric-v"); break;
        case Type::SYMMETRIC_LINE:      s = C_("constr-name", "symmetric-line"); break;
        case Type::AT_MIDPOINT:         s = C_("constr-name", "at-midpoint"); break;
        case Type::HORIZONTAL:          s = C_("constr-name", "horizontal"); break;
        case Type::VERTICAL:            s = C_("constr-name", "vertical"); break;
        case Type::DIAMETER:            s = C_("constr-name", "diameter"); break;
        case Type::PT_ON_CIRCLE:        s = C_("constr-name", "pt-on-circle"); break;
        case Type::SAME_ORIENTATION:    s = C_("constr-name", "same-orientation"); break;
        case Type::ANGLE:               s = C_("constr-name", "angle"); break;
        case Type::PARALLEL:            s = C_("constr-name", "parallel"); break;
        case Type::ARC_LINE_TANGENT:    s = C_("constr-name", "arc-line-tangent"); break;
        case Type::CUBIC_LINE_TANGENT:  s = C_("constr-name", "cubic-line-tangent"); break;
        case Type::CURVE_CURVE_TANGENT: s = C_("constr-name", "curve-curve-tangent"); break;
        case Type::PERPENDICULAR:       s = C_("constr-name", "perpendicular"); break;
        case Type::EQUAL_RADIUS:        s = C_("constr-name", "eq-radius"); break;
        case Type::EQUAL_ANGLE:         s = C_("constr-name", "eq-angle"); break;
        case Type::EQUAL_LINE_ARC_LEN:  s = C_("constr-name", "eq-line-len-arc-len"); break;
        case Type::WHERE_DRAGGED:       s = C_("constr-name", "lock-where-dragged"); break;
        case Type::COMMENT:             s = C_("constr-name", "comment"); break;
        default:                        s = "???"; break;
    }

    return ssprintf("c%03x-%s", h.v, s.c_str());
}

#ifndef LIBRARY

//-----------------------------------------------------------------------------
// Delete all constraints with the specified type, entityA, ptA. We use this
// when auto-removing constraints that would become redundant.
//-----------------------------------------------------------------------------
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20171226104022.20">bool EntityBase::IsDistance() const {
    return (type == Type::DISTANCE) ||
           (type == Type::DISTANCE_N_COPY);
}
double EntityBase::DistanceGetNum() const {
    if(type == Type::DISTANCE) {
        return SK.GetParam(param[0])-&gt;val;
    } else if(type == Type::DISTANCE_N_COPY) {
        return numDistance;
    } else ssassert(false, "Unexpected entity type");
}
Expr *EntityBase::DistanceGetExpr() const {
    if(type == Type::DISTANCE) {
        return Expr::From(param[0]);
    } else if(type == Type::DISTANCE_N_COPY) {
        return Expr::From(numDistance);
    } else ssassert(false, "Unexpected entity type");
}
</t>
<t tx="leo.20171226104022.21">void EntityBase::DistanceForceTo(double v) {
    if(type == Type::DISTANCE) {
        (SK.GetParam(param[0]))-&gt;val = v;
    } else if(type == Type::DISTANCE_N_COPY) {
        // do nothing, it's locked
    } else ssassert(false, "Unexpected entity type");
}

EntityBase *EntityBase::Normal() const {
    return SK.GetEntity(normal);
}

</t>
<t tx="leo.20171226104022.22">bool EntityBase::IsPoint() const {
    switch(type) {
        case Type::POINT_IN_3D:
        case Type::POINT_IN_2D:
        case Type::POINT_N_COPY:
        case Type::POINT_N_TRANS:
        case Type::POINT_N_ROT_TRANS:
        case Type::POINT_N_ROT_AA:
            return true;

        default:
            return false;
    }
}

</t>
<t tx="leo.20171226104022.23">bool EntityBase::IsNormal() const {
    switch(type) {
        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
            return true;

        default:           return false;
    }
}

Quaternion EntityBase::NormalGetNum() const {
    Quaternion q;
    switch(type) {
        case Type::NORMAL_IN_3D:
            q = Quaternion::From(param[0], param[1], param[2], param[3]);
            break;

        case Type::NORMAL_IN_2D: {
            EntityBase *wrkpl = SK.GetEntity(workplane);
            EntityBase *norm = SK.GetEntity(wrkpl-&gt;normal);
            q = norm-&gt;NormalGetNum();
            break;
        }
        case Type::NORMAL_N_COPY:
            q = numNormal;
            break;

        case Type::NORMAL_N_ROT:
            q = Quaternion::From(param[0], param[1], param[2], param[3]);
            q = q.Times(numNormal);
            break;

        case Type::NORMAL_N_ROT_AA: {
            q = GetAxisAngleQuaternion(0);
            q = q.Times(numNormal);
            break;
        }

        default: ssassert(false, "Unexpected entity type");
    }
    return q;
}

</t>
<t tx="leo.20171226104022.24">void EntityBase::NormalForceTo(Quaternion q) {
    switch(type) {
        case Type::NORMAL_IN_3D:
            SK.GetParam(param[0])-&gt;val = q.w;
            SK.GetParam(param[1])-&gt;val = q.vx;
            SK.GetParam(param[2])-&gt;val = q.vy;
            SK.GetParam(param[3])-&gt;val = q.vz;
            break;

        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
            // There's absolutely nothing to do; these are locked.
            break;
        case Type::NORMAL_N_ROT: {
            Quaternion qp = q.Times(numNormal.Inverse());

            SK.GetParam(param[0])-&gt;val = qp.w;
            SK.GetParam(param[1])-&gt;val = qp.vx;
            SK.GetParam(param[2])-&gt;val = qp.vy;
            SK.GetParam(param[3])-&gt;val = qp.vz;
            break;
        }

        case Type::NORMAL_N_ROT_AA:
            // Not sure if I'll bother implementing this one
            break;

        default: ssassert(false, "Unexpected entity type");
    }
}

Vector EntityBase::NormalU() const {
    return NormalGetNum().RotationU();
}
Vector EntityBase::NormalV() const {
    return NormalGetNum().RotationV();
}
Vector EntityBase::NormalN() const {
    return NormalGetNum().RotationN();
}

ExprVector EntityBase::NormalExprsU() const {
    return NormalGetExprs().RotationU();
}
ExprVector EntityBase::NormalExprsV() const {
    return NormalGetExprs().RotationV();
}
ExprVector EntityBase::NormalExprsN() const {
    return NormalGetExprs().RotationN();
}

ExprQuaternion EntityBase::NormalGetExprs() const {
    ExprQuaternion q;
    switch(type) {
        case Type::NORMAL_IN_3D:
            q = ExprQuaternion::From(param[0], param[1], param[2], param[3]);
            break;

        case Type::NORMAL_IN_2D: {
            EntityBase *wrkpl = SK.GetEntity(workplane);
            EntityBase *norm = SK.GetEntity(wrkpl-&gt;normal);
            q = norm-&gt;NormalGetExprs();
            break;
        }
        case Type::NORMAL_N_COPY:
            q = ExprQuaternion::From(numNormal);
            break;

        case Type::NORMAL_N_ROT: {
            ExprQuaternion orig = ExprQuaternion::From(numNormal);
            q = ExprQuaternion::From(param[0], param[1], param[2], param[3]);

            q = q.Times(orig);
            break;
        }

        case Type::NORMAL_N_ROT_AA: {
            ExprQuaternion orig = ExprQuaternion::From(numNormal);
            q = GetAxisAngleQuaternionExprs(0);
            q = q.Times(orig);
            break;
        }

        default: ssassert(false, "Unexpected entity type");
    }
    return q;
}

</t>
<t tx="leo.20171226104022.25">void EntityBase::PointForceParamTo(Vector p) {
    switch(type) {
        case Type::POINT_IN_3D:
            SK.GetParam(param[0])-&gt;val = p.x;
            SK.GetParam(param[1])-&gt;val = p.y;
            SK.GetParam(param[2])-&gt;val = p.z;
            break;

        case Type::POINT_IN_2D:
            SK.GetParam(param[0])-&gt;val = p.x;
            SK.GetParam(param[1])-&gt;val = p.y;
            break;

        default: ssassert(false, "Unexpected entity type");
    }
}

</t>
<t tx="leo.20171226104022.26">void EntityBase::PointForceTo(Vector p) {
    switch(type) {
        case Type::POINT_IN_3D:
            SK.GetParam(param[0])-&gt;val = p.x;
            SK.GetParam(param[1])-&gt;val = p.y;
            SK.GetParam(param[2])-&gt;val = p.z;
            break;

        case Type::POINT_IN_2D: {
            EntityBase *c = SK.GetEntity(workplane);
            p = p.Minus(c-&gt;WorkplaneGetOffset());
            SK.GetParam(param[0])-&gt;val = p.Dot(c-&gt;Normal()-&gt;NormalU());
            SK.GetParam(param[1])-&gt;val = p.Dot(c-&gt;Normal()-&gt;NormalV());
            break;
        }

        case Type::POINT_N_TRANS: {
            if(timesApplied == 0) break;
            Vector trans = (p.Minus(numPoint)).ScaledBy(1.0/timesApplied);
            SK.GetParam(param[0])-&gt;val = trans.x;
            SK.GetParam(param[1])-&gt;val = trans.y;
            SK.GetParam(param[2])-&gt;val = trans.z;
            break;
        }

        case Type::POINT_N_ROT_TRANS: {
            // Force only the translation; leave the rotation unchanged. But
            // remember that we're working with respect to the rotated
            // point.
            Vector trans = p.Minus(PointGetQuaternion().Rotate(numPoint));
            SK.GetParam(param[0])-&gt;val = trans.x;
            SK.GetParam(param[1])-&gt;val = trans.y;
            SK.GetParam(param[2])-&gt;val = trans.z;
            break;
        }

        case Type::POINT_N_ROT_AA: {
            // Force only the angle; the axis and center of rotation stay
            Vector offset = Vector::From(param[0], param[1], param[2]);
            Vector normal = Vector::From(param[4], param[5], param[6]);
            Vector u = normal.Normal(0), v = normal.Normal(1);
            Vector po = p.Minus(offset), numo = numPoint.Minus(offset);
            double thetap = atan2(v.Dot(po), u.Dot(po));
            double thetan = atan2(v.Dot(numo), u.Dot(numo));
            double thetaf = (thetap - thetan);
            double thetai = (SK.GetParam(param[3])-&gt;val)*timesApplied*2;
            double dtheta = thetaf - thetai;
            // Take the smallest possible change in the actual step angle,
            // in order to avoid jumps when you cross from +pi to -pi
            while(dtheta &lt; -PI) dtheta += 2*PI;
            while(dtheta &gt; PI) dtheta -= 2*PI;
            SK.GetParam(param[3])-&gt;val = (thetai + dtheta)/(timesApplied*2);
            break;
        }

        case Type::POINT_N_COPY:
            // Nothing to do; it's a static copy
            break;

        default: ssassert(false, "Unexpected entity type");
    }
}

Vector EntityBase::PointGetNum() const {
    Vector p;
    switch(type) {
        case Type::POINT_IN_3D:
            p = Vector::From(param[0], param[1], param[2]);
            break;

        case Type::POINT_IN_2D: {
            EntityBase *c = SK.GetEntity(workplane);
            Vector u = c-&gt;Normal()-&gt;NormalU();
            Vector v = c-&gt;Normal()-&gt;NormalV();
            p =        u.ScaledBy(SK.GetParam(param[0])-&gt;val);
            p = p.Plus(v.ScaledBy(SK.GetParam(param[1])-&gt;val));
            p = p.Plus(c-&gt;WorkplaneGetOffset());
            break;
        }

        case Type::POINT_N_TRANS: {
            Vector trans = Vector::From(param[0], param[1], param[2]);
            p = numPoint.Plus(trans.ScaledBy(timesApplied));
            break;
        }

        case Type::POINT_N_ROT_TRANS: {
            Vector offset = Vector::From(param[0], param[1], param[2]);
            Quaternion q = PointGetQuaternion();
            p = q.Rotate(numPoint);
            p = p.Plus(offset);
            break;
        }

        case Type::POINT_N_ROT_AA: {
            Vector offset = Vector::From(param[0], param[1], param[2]);
            Quaternion q = PointGetQuaternion();
            p = numPoint.Minus(offset);
            p = q.Rotate(p);
            p = p.Plus(offset);
            break;
        }

        case Type::POINT_N_COPY:
            p = numPoint;
            break;

        default: ssassert(false, "Unexpected entity type");
    }
    return p;
}

ExprVector EntityBase::PointGetExprs() const {
    ExprVector r;
    switch(type) {
        case Type::POINT_IN_3D:
            r = ExprVector::From(param[0], param[1], param[2]);
            break;

        case Type::POINT_IN_2D: {
            EntityBase *c = SK.GetEntity(workplane);
            ExprVector u = c-&gt;Normal()-&gt;NormalExprsU();
            ExprVector v = c-&gt;Normal()-&gt;NormalExprsV();
            r = c-&gt;WorkplaneGetOffsetExprs();
            r = r.Plus(u.ScaledBy(Expr::From(param[0])));
            r = r.Plus(v.ScaledBy(Expr::From(param[1])));
            break;
        }
        case Type::POINT_N_TRANS: {
            ExprVector orig = ExprVector::From(numPoint);
            ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
            r = orig.Plus(trans.ScaledBy(Expr::From(timesApplied)));
            break;
        }
        case Type::POINT_N_ROT_TRANS: {
            ExprVector orig = ExprVector::From(numPoint);
            ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
            ExprQuaternion q =
                ExprQuaternion::From(param[3], param[4], param[5], param[6]);
            orig = q.Rotate(orig);
            r = orig.Plus(trans);
            break;
        }
        case Type::POINT_N_ROT_AA: {
            ExprVector orig = ExprVector::From(numPoint);
            ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
            ExprQuaternion q = GetAxisAngleQuaternionExprs(3);
            orig = orig.Minus(trans);
            orig = q.Rotate(orig);
            r = orig.Plus(trans);
            break;
        }
        case Type::POINT_N_COPY:
            r = ExprVector::From(numPoint);
            break;

        default: ssassert(false, "Unexpected entity type");
    }
    return r;
}

</t>
<t tx="leo.20171226104022.27">void EntityBase::PointGetExprsInWorkplane(hEntity wrkpl, Expr **u, Expr **v) const {
    if(type == Type::POINT_IN_2D &amp;&amp; workplane.v == wrkpl.v) {
        // They want our coordinates in the form that we've written them,
        // very nice.
        *u = Expr::From(param[0]);
        *v = Expr::From(param[1]);
    } else {
        // Get the offset and basis vectors for this weird exotic csys.
        EntityBase *w = SK.GetEntity(wrkpl);
        ExprVector wp = w-&gt;WorkplaneGetOffsetExprs();
        ExprVector wu = w-&gt;Normal()-&gt;NormalExprsU();
        ExprVector wv = w-&gt;Normal()-&gt;NormalExprsV();

        // Get our coordinates in three-space, and project them into that
        // coordinate system.
        ExprVector ev = PointGetExprs();
        ev = ev.Minus(wp);
        *u = ev.Dot(wu);
        *v = ev.Dot(wv);
    }
}

ExprVector EntityBase::PointGetExprsInWorkplane(hEntity wrkpl) const {
    if(wrkpl.v == Entity::FREE_IN_3D.v) {
        return PointGetExprs();
    }

    ExprVector r;
    PointGetExprsInWorkplane(wrkpl, &amp;r.x, &amp;r.y);
    r.z = Expr::From(0.0);
    return r;
}

</t>
<t tx="leo.20171226104022.28">void EntityBase::PointForceQuaternionTo(Quaternion q) {
    ssassert(type == Type::POINT_N_ROT_TRANS, "Unexpected entity type");

    SK.GetParam(param[3])-&gt;val = q.w;
    SK.GetParam(param[4])-&gt;val = q.vx;
    SK.GetParam(param[5])-&gt;val = q.vy;
    SK.GetParam(param[6])-&gt;val = q.vz;
}

Quaternion EntityBase::GetAxisAngleQuaternion(int param0) const {
    Quaternion q;
    double theta = timesApplied*SK.GetParam(param[param0+0])-&gt;val;
    double s = sin(theta), c = cos(theta);
    q.w = c;
    q.vx = s*SK.GetParam(param[param0+1])-&gt;val;
    q.vy = s*SK.GetParam(param[param0+2])-&gt;val;
    q.vz = s*SK.GetParam(param[param0+3])-&gt;val;
    return q;
}

ExprQuaternion EntityBase::GetAxisAngleQuaternionExprs(int param0) const {
    ExprQuaternion q;

    Expr *theta = Expr::From(timesApplied)-&gt;Times(
                  Expr::From(param[param0+0]));
    Expr *c = theta-&gt;Cos(), *s = theta-&gt;Sin();
    q.w = c;
    q.vx = s-&gt;Times(Expr::From(param[param0+1]));
    q.vy = s-&gt;Times(Expr::From(param[param0+2]));
    q.vz = s-&gt;Times(Expr::From(param[param0+3]));
    return q;
}

Quaternion EntityBase::PointGetQuaternion() const {
    Quaternion q;

    if(type == Type::POINT_N_ROT_AA) {
        q = GetAxisAngleQuaternion(3);
    } else if(type == Type::POINT_N_ROT_TRANS) {
        q = Quaternion::From(param[3], param[4], param[5], param[6]);
    } else ssassert(false, "Unexpected entity type");

    return q;
}

</t>
<t tx="leo.20171226104022.29">bool EntityBase::IsFace() const {
    switch(type) {
        case Type::FACE_NORMAL_PT:
        case Type::FACE_XPROD:
        case Type::FACE_N_ROT_TRANS:
        case Type::FACE_N_TRANS:
        case Type::FACE_N_ROT_AA:
            return true;
        default:
            return false;
    }
}

ExprVector EntityBase::FaceGetNormalExprs() const {
    ExprVector r;
    if(type == Type::FACE_NORMAL_PT) {
        Vector v = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        r = ExprVector::From(v.WithMagnitude(1));
    } else if(type == Type::FACE_XPROD) {
        ExprVector vc = ExprVector::From(param[0], param[1], param[2]);
        ExprVector vn =
            ExprVector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        r = vc.Cross(vn);
        r = r.WithMagnitude(Expr::From(1.0));
    } else if(type == Type::FACE_N_ROT_TRANS) {
        // The numerical normal vector gets the rotation; the numerical
        // normal has magnitude one, and the rotation doesn't change that,
        // so there's no need to fix it up.
        r = ExprVector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        ExprQuaternion q =
            ExprQuaternion::From(param[3], param[4], param[5], param[6]);
        r = q.Rotate(r);
    } else if(type == Type::FACE_N_TRANS) {
        r = ExprVector::From(numNormal.vx, numNormal.vy, numNormal.vz);
    } else if(type == Type::FACE_N_ROT_AA) {
        r = ExprVector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        ExprQuaternion q = GetAxisAngleQuaternionExprs(3);
        r = q.Rotate(r);
    } else ssassert(false, "Unexpected entity type");
    return r;
}

Vector EntityBase::FaceGetNormalNum() const {
    Vector r;
    if(type == Type::FACE_NORMAL_PT) {
        r = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
    } else if(type == Type::FACE_XPROD) {
        Vector vc = Vector::From(param[0], param[1], param[2]);
        Vector vn = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        r = vc.Cross(vn);
    } else if(type == Type::FACE_N_ROT_TRANS) {
        // The numerical normal vector gets the rotation
        r = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        Quaternion q = Quaternion::From(param[3], param[4], param[5], param[6]);
        r = q.Rotate(r);
    } else if(type == Type::FACE_N_TRANS) {
        r = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
    } else if(type == Type::FACE_N_ROT_AA) {
        r = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        Quaternion q = GetAxisAngleQuaternion(3);
        r = q.Rotate(r);
    } else ssassert(false, "Unexpected entity type");
    return r.WithMagnitude(1);
}

ExprVector EntityBase::FaceGetPointExprs() const {
    ExprVector r;
    if(type == Type::FACE_NORMAL_PT) {
        r = SK.GetEntity(point[0])-&gt;PointGetExprs();
    } else if(type == Type::FACE_XPROD) {
        r = ExprVector::From(numPoint);
    } else if(type == Type::FACE_N_ROT_TRANS) {
        // The numerical point gets the rotation and translation.
        ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
        ExprQuaternion q =
            ExprQuaternion::From(param[3], param[4], param[5], param[6]);
        r = ExprVector::From(numPoint);
        r = q.Rotate(r);
        r = r.Plus(trans);
    } else if(type == Type::FACE_N_TRANS) {
        ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
        r = ExprVector::From(numPoint);
        r = r.Plus(trans.ScaledBy(Expr::From(timesApplied)));
    } else if(type == Type::FACE_N_ROT_AA) {
        ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
        ExprQuaternion q = GetAxisAngleQuaternionExprs(3);
        r = ExprVector::From(numPoint);
        r = r.Minus(trans);
        r = q.Rotate(r);
        r = r.Plus(trans);
    } else ssassert(false, "Unexpected entity type");
    return r;
}

Vector EntityBase::FaceGetPointNum() const {
    Vector r;
    if(type == Type::FACE_NORMAL_PT) {
        r = SK.GetEntity(point[0])-&gt;PointGetNum();
    } else if(type == Type::FACE_XPROD) {
        r = numPoint;
    } else if(type == Type::FACE_N_ROT_TRANS) {
        // The numerical point gets the rotation and translation.
        Vector trans = Vector::From(param[0], param[1], param[2]);
        Quaternion q = Quaternion::From(param[3], param[4], param[5], param[6]);
        r = q.Rotate(numPoint);
        r = r.Plus(trans);
    } else if(type == Type::FACE_N_TRANS) {
        Vector trans = Vector::From(param[0], param[1], param[2]);
        r = numPoint.Plus(trans.ScaledBy(timesApplied));
    } else if(type == Type::FACE_N_ROT_AA) {
        Vector trans = Vector::From(param[0], param[1], param[2]);
        Quaternion q = GetAxisAngleQuaternion(3);
        r = numPoint.Minus(trans);
        r = q.Rotate(r);
        r = r.Plus(trans);
    } else ssassert(false, "Unexpected entity type");
    return r;
}

</t>
<t tx="leo.20171226104022.3">void Constraint::DeleteAllConstraintsFor(Constraint::Type type, hEntity entityA, hEntity ptA)
{
    SK.constraint.ClearTags();
    for(int i = 0; i &lt; SK.constraint.n; i++) {
        ConstraintBase *ct = &amp;(SK.constraint.elem[i]);
        if(ct-&gt;type != type) continue;

        if(ct-&gt;entityA.v != entityA.v) continue;
        if(ct-&gt;ptA.v != ptA.v) continue;
        ct-&gt;tag = 1;
    }
    SK.constraint.RemoveTagged();
    // And no need to do anything special, since nothing
    // ever depends on a constraint. But do clear the
    // hover, in case the just-deleted constraint was
    // hovered.
    SS.GW.hover.Clear();
}

hConstraint Constraint::AddConstraint(Constraint *c) {
    return AddConstraint(c, /*rememberForUndo=*/true);
}

hConstraint Constraint::AddConstraint(Constraint *c, bool rememberForUndo) {
    if(rememberForUndo) SS.UndoRemember();

    hConstraint hc = SK.constraint.AddAndAssignId(c);
    SK.GetConstraint(hc)-&gt;Generate(&amp;SK.param);

    SS.MarkGroupDirty(c-&gt;group);
    SK.GetGroup(c-&gt;group)-&gt;dofCheckOk = false;
    return c-&gt;h;
}

hConstraint Constraint::Constrain(Constraint::Type type, hEntity ptA, hEntity ptB,
                                     hEntity entityA, hEntity entityB,
</t>
<t tx="leo.20171226104022.30">bool EntityBase::HasEndpoints() const {
    return (type == Type::LINE_SEGMENT) ||
           (type == Type::CUBIC) ||
           (type == Type::ARC_OF_CIRCLE);
}
Vector EntityBase::EndpointStart() const {
    if(type == Type::LINE_SEGMENT) {
        return SK.GetEntity(point[0])-&gt;PointGetNum();
    } else if(type == Type::CUBIC) {
        return CubicGetStartNum();
    } else if(type == Type::ARC_OF_CIRCLE) {
        return SK.GetEntity(point[1])-&gt;PointGetNum();
    } else ssassert(false, "Unexpected entity type");
}
Vector EntityBase::EndpointFinish() const {
    if(type == Type::LINE_SEGMENT) {
        return SK.GetEntity(point[1])-&gt;PointGetNum();
    } else if(type == Type::CUBIC) {
        return CubicGetFinishNum();
    } else if(type == Type::ARC_OF_CIRCLE) {
        return SK.GetEntity(point[2])-&gt;PointGetNum();
    } else ssassert(false, "Unexpected entity type");
}

</t>
<t tx="leo.20171226104022.31">void EntityBase::RectGetPointsExprs(ExprVector *eb, ExprVector *ec) const {
    ssassert(type == Type::TTF_TEXT || type == Type::IMAGE,
             "Unexpected entity type");

    EntityBase *a = SK.GetEntity(point[0]);
    EntityBase *o = SK.GetEntity(point[1]);

    // Write equations for each point in the current workplane.
    // This reduces the complexity of resulting equations.
    ExprVector ea = a-&gt;PointGetExprsInWorkplane(workplane);
    ExprVector eo = o-&gt;PointGetExprsInWorkplane(workplane);

    // Take perpendicular vector and scale it by aspect ratio.
    ExprVector eu = ea.Minus(eo);
    ExprVector ev = ExprVector::From(eu.y, eu.x-&gt;Negate(), eu.z).ScaledBy(Expr::From(aspectRatio));

    *eb = eo.Plus(ev);
    *ec = eo.Plus(eu).Plus(ev);
}

</t>
<t tx="leo.20171226104022.32">void EntityBase::AddEq(IdList&lt;Equation,hEquation&gt; *l, Expr *expr, int index) const {
    Equation eq;
    eq.e = expr;
    eq.h = h.equation(index);
    l-&gt;Add(&amp;eq);
}

</t>
<t tx="leo.20171226104022.33">void EntityBase::GenerateEquations(IdList&lt;Equation,hEquation&gt; *l) const {
    switch(type) {
        case Type::NORMAL_IN_3D: {
            ExprQuaternion q = NormalGetExprs();
            AddEq(l, (q.Magnitude())-&gt;Minus(Expr::From(1)), 0);
            break;
        }

        case Type::ARC_OF_CIRCLE: {
            // If this is a copied entity, with its point already fixed
            // with respect to each other, then we don't want to generate
            // the distance constraint!
            if(SK.GetEntity(point[0])-&gt;type != Type::POINT_IN_2D) break;

            // If the two endpoints of the arc are constrained coincident
            // (to make a complete circle), then our distance constraint
            // would be redundant and therefore overconstrain things.
            int i;
            for(i = 0; i &lt; SK.constraint.n; i++) {
                ConstraintBase *c = &amp;(SK.constraint.elem[i]);
                if(c-&gt;group.v != group.v) continue;
                if(c-&gt;type != Constraint::Type::POINTS_COINCIDENT) continue;

                if((c-&gt;ptA.v == point[1].v &amp;&amp; c-&gt;ptB.v == point[2].v) ||
                   (c-&gt;ptA.v == point[2].v &amp;&amp; c-&gt;ptB.v == point[1].v))
                {
                    break;
                }
            }
            if(i &lt; SK.constraint.n) break;

            Expr *ra = Constraint::Distance(workplane, point[0], point[1]);
            Expr *rb = Constraint::Distance(workplane, point[0], point[2]);
            AddEq(l, ra-&gt;Minus(rb), 0);
            break;
        }

        case Type::IMAGE:
        case Type::TTF_TEXT: {
            if(SK.GetEntity(point[0])-&gt;type != Type::POINT_IN_2D) break;
            EntityBase *b = SK.GetEntity(point[2]);
            EntityBase *c = SK.GetEntity(point[3]);
            ExprVector eb = b-&gt;PointGetExprsInWorkplane(workplane);
            ExprVector ec = c-&gt;PointGetExprsInWorkplane(workplane);

            ExprVector ebp, ecp;
            RectGetPointsExprs(&amp;ebp, &amp;ecp);

            ExprVector beq = eb.Minus(ebp);
            AddEq(l, beq.x, 0);
            AddEq(l, beq.y, 1);
            ExprVector ceq = ec.Minus(ecp);
            AddEq(l, ceq.x, 2);
            AddEq(l, ceq.y, 3);
            break;
        }

        default: // Most entities do not generate equations.
            break;
    }
}
</t>
<t tx="leo.20171226104022.34">//-----------------------------------------------------------------------------
// The symbolic algebra system used to write our constraint equations;
// routines to build expressions in software or from a user-provided string,
// and to compute the partial derivatives that we'll use when write our
// Jacobian matrix.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

ExprVector ExprVector::From(Expr *x, Expr *y, Expr *z) {
    ExprVector r = { x, y, z};
    return r;
}

ExprVector ExprVector::From(Vector vn) {
    ExprVector ve;
    ve.x = Expr::From(vn.x);
    ve.y = Expr::From(vn.y);
    ve.z = Expr::From(vn.z);
    return ve;
}

ExprVector ExprVector::From(hParam x, hParam y, hParam z) {
    ExprVector ve;
    ve.x = Expr::From(x);
    ve.y = Expr::From(y);
    ve.z = Expr::From(z);
    return ve;
}

ExprVector ExprVector::From(double x, double y, double z) {
    ExprVector ve;
    ve.x = Expr::From(x);
    ve.y = Expr::From(y);
    ve.z = Expr::From(z);
    return ve;
}

ExprVector ExprVector::Minus(ExprVector b) const {
    ExprVector r;
    r.x = x-&gt;Minus(b.x);
    r.y = y-&gt;Minus(b.y);
    r.z = z-&gt;Minus(b.z);
    return r;
}

ExprVector ExprVector::Plus(ExprVector b) const {
    ExprVector r;
    r.x = x-&gt;Plus(b.x);
    r.y = y-&gt;Plus(b.y);
    r.z = z-&gt;Plus(b.z);
    return r;
}

Expr *ExprVector::Dot(ExprVector b) const {
    Expr *r;
    r =         x-&gt;Times(b.x);
    r = r-&gt;Plus(y-&gt;Times(b.y));
    r = r-&gt;Plus(z-&gt;Times(b.z));
    return r;
}

ExprVector ExprVector::Cross(ExprVector b) const {
    ExprVector r;
    r.x = (y-&gt;Times(b.z))-&gt;Minus(z-&gt;Times(b.y));
    r.y = (z-&gt;Times(b.x))-&gt;Minus(x-&gt;Times(b.z));
    r.z = (x-&gt;Times(b.y))-&gt;Minus(y-&gt;Times(b.x));
    return r;
}

ExprVector ExprVector::ScaledBy(Expr *s) const {
    ExprVector r;
    r.x = x-&gt;Times(s);
    r.y = y-&gt;Times(s);
    r.z = z-&gt;Times(s);
    return r;
}

ExprVector ExprVector::WithMagnitude(Expr *s) const {
    Expr *m = Magnitude();
    return ScaledBy(s-&gt;Div(m));
}

Expr *ExprVector::Magnitude() const {
    Expr *r;
    r =         x-&gt;Square();
    r = r-&gt;Plus(y-&gt;Square());
    r = r-&gt;Plus(z-&gt;Square());
    return r-&gt;Sqrt();
}

Vector ExprVector::Eval() const {
    Vector r;
    r.x = x-&gt;Eval();
    r.y = y-&gt;Eval();
    r.z = z-&gt;Eval();
    return r;
}

ExprQuaternion ExprQuaternion::From(hParam w, hParam vx, hParam vy, hParam vz) {
    ExprQuaternion q;
    q.w  = Expr::From(w);
    q.vx = Expr::From(vx);
    q.vy = Expr::From(vy);
    q.vz = Expr::From(vz);
    return q;
}

ExprQuaternion ExprQuaternion::From(Expr *w, Expr *vx, Expr *vy, Expr *vz)
{
    ExprQuaternion q;
    q.w = w;
    q.vx = vx;
    q.vy = vy;
    q.vz = vz;
    return q;
}

ExprQuaternion ExprQuaternion::From(Quaternion qn) {
    ExprQuaternion qe;
    qe.w = Expr::From(qn.w);
    qe.vx = Expr::From(qn.vx);
    qe.vy = Expr::From(qn.vy);
    qe.vz = Expr::From(qn.vz);
    return qe;
}

ExprVector ExprQuaternion::RotationU() const {
    ExprVector u;
    Expr *two = Expr::From(2);

    u.x = w-&gt;Square();
    u.x = (u.x)-&gt;Plus(vx-&gt;Square());
    u.x = (u.x)-&gt;Minus(vy-&gt;Square());
    u.x = (u.x)-&gt;Minus(vz-&gt;Square());

    u.y = two-&gt;Times(w-&gt;Times(vz));
    u.y = (u.y)-&gt;Plus(two-&gt;Times(vx-&gt;Times(vy)));

    u.z = two-&gt;Times(vx-&gt;Times(vz));
    u.z = (u.z)-&gt;Minus(two-&gt;Times(w-&gt;Times(vy)));

    return u;
}

ExprVector ExprQuaternion::RotationV() const {
    ExprVector v;
    Expr *two = Expr::From(2);

    v.x = two-&gt;Times(vx-&gt;Times(vy));
    v.x = (v.x)-&gt;Minus(two-&gt;Times(w-&gt;Times(vz)));

    v.y = w-&gt;Square();
    v.y = (v.y)-&gt;Minus(vx-&gt;Square());
    v.y = (v.y)-&gt;Plus(vy-&gt;Square());
    v.y = (v.y)-&gt;Minus(vz-&gt;Square());

    v.z = two-&gt;Times(w-&gt;Times(vx));
    v.z = (v.z)-&gt;Plus(two-&gt;Times(vy-&gt;Times(vz)));

    return v;
}

ExprVector ExprQuaternion::RotationN() const {
    ExprVector n;
    Expr *two = Expr::From(2);

    n.x =              two-&gt;Times( w-&gt;Times(vy));
    n.x = (n.x)-&gt;Plus (two-&gt;Times(vx-&gt;Times(vz)));

    n.y =              two-&gt;Times(vy-&gt;Times(vz));
    n.y = (n.y)-&gt;Minus(two-&gt;Times( w-&gt;Times(vx)));

    n.z =               w-&gt;Square();
    n.z = (n.z)-&gt;Minus(vx-&gt;Square());
    n.z = (n.z)-&gt;Minus(vy-&gt;Square());
    n.z = (n.z)-&gt;Plus (vz-&gt;Square());

    return n;
}

ExprVector ExprQuaternion::Rotate(ExprVector p) const {
    // Express the point in the new basis
    return (RotationU().ScaledBy(p.x)).Plus(
            RotationV().ScaledBy(p.y)).Plus(
            RotationN().ScaledBy(p.z));
}

ExprQuaternion ExprQuaternion::Times(ExprQuaternion b) const {
    Expr *sa = w, *sb = b.w;
    ExprVector va = { vx, vy, vz };
    ExprVector vb = { b.vx, b.vy, b.vz };

    ExprQuaternion r;
    r.w = (sa-&gt;Times(sb))-&gt;Minus(va.Dot(vb));
    ExprVector vr = vb.ScaledBy(sa).Plus(
                    va.ScaledBy(sb).Plus(
                    va.Cross(vb)));
    r.vx = vr.x;
    r.vy = vr.y;
    r.vz = vr.z;
    return r;
}

Expr *ExprQuaternion::Magnitude() const {
    return ((w -&gt;Square())-&gt;Plus(
            (vx-&gt;Square())-&gt;Plus(
            (vy-&gt;Square())-&gt;Plus(
            (vz-&gt;Square())))))-&gt;Sqrt();
}


Expr *Expr::From(hParam p) {
    Expr *r = AllocExpr();
    r-&gt;op = Op::PARAM;
    r-&gt;parh = p;
    return r;
}

Expr *Expr::From(double v) {
    // Statically allocate common constants.
    // Note: this is only valid because AllocExpr() uses AllocTemporary(),
    // and Expr* is never explicitly freed.

    if(v == 0.0) {
        static Expr zero(0.0);
        return &amp;zero;
    }

    if(v == 1.0) {
        static Expr one(1.0);
        return &amp;one;
    }

    if(v == -1.0) {
        static Expr mone(-1.0);
        return &amp;mone;
    }

    if(v == 0.5) {
        static Expr half(0.5);
        return &amp;half;
    }

    if(v == -0.5) {
        static Expr mhalf(-0.5);
        return &amp;mhalf;
    }

    Expr *r = AllocExpr();
    r-&gt;op = Op::CONSTANT;
    r-&gt;v = v;
    return r;
}

Expr *Expr::AnyOp(Op newOp, Expr *b) {
    Expr *r = AllocExpr();
    r-&gt;op = newOp;
    r-&gt;a = this;
    r-&gt;b = b;
    return r;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20171226104022.35">int Expr::Children() const {
    switch(op) {
        case Op::PARAM:
        case Op::PARAM_PTR:
        case Op::CONSTANT:
        case Op::VARIABLE:
            return 0;

        case Op::PLUS:
        case Op::MINUS:
        case Op::TIMES:
        case Op::DIV:
            return 2;

        case Op::NEGATE:
        case Op::SQRT:
        case Op::SQUARE:
        case Op::SIN:
        case Op::COS:
        case Op::ASIN:
        case Op::ACOS:
            return 1;
    }
    ssassert(false, "Unexpected operation");
}

</t>
<t tx="leo.20171226104022.36">int Expr::Nodes() const {
    switch(Children()) {
        case 0: return 1;
        case 1: return 1 + a-&gt;Nodes();
        case 2: return 1 + a-&gt;Nodes() + b-&gt;Nodes();
        default: ssassert(false, "Unexpected children count");
    }
}

Expr *Expr::DeepCopy() const {
    Expr *n = AllocExpr();
    *n = *this;
    int c = n-&gt;Children();
    if(c &gt; 0) n-&gt;a = a-&gt;DeepCopy();
    if(c &gt; 1) n-&gt;b = b-&gt;DeepCopy();
    return n;
}

Expr *Expr::DeepCopyWithParamsAsPointers(IdList&lt;Param,hParam&gt; *firstTry,
    IdList&lt;Param,hParam&gt; *thenTry) const
{
    Expr *n = AllocExpr();
    if(op == Op::PARAM) {
        // A param that is referenced by its hParam gets rewritten to go
        // straight in to the parameter table with a pointer, or simply
        // into a constant if it's already known.
        Param *p = firstTry-&gt;FindByIdNoOops(parh);
        if(!p) p = thenTry-&gt;FindById(parh);
        if(p-&gt;known) {
            n-&gt;op = Op::CONSTANT;
            n-&gt;v = p-&gt;val;
        } else {
            n-&gt;op = Op::PARAM_PTR;
            n-&gt;parp = p;
        }
        return n;
    }

    *n = *this;
    int c = n-&gt;Children();
    if(c &gt; 0) n-&gt;a = a-&gt;DeepCopyWithParamsAsPointers(firstTry, thenTry);
    if(c &gt; 1) n-&gt;b = b-&gt;DeepCopyWithParamsAsPointers(firstTry, thenTry);
    return n;
}

double Expr::Eval() const {
    switch(op) {
        case Op::PARAM:         return SK.GetParam(parh)-&gt;val;
        case Op::PARAM_PTR:     return parp-&gt;val;

        case Op::CONSTANT:      return v;
        case Op::VARIABLE:      ssassert(false, "Not supported yet");

        case Op::PLUS:          return a-&gt;Eval() + b-&gt;Eval();
        case Op::MINUS:         return a-&gt;Eval() - b-&gt;Eval();
        case Op::TIMES:         return a-&gt;Eval() * b-&gt;Eval();
        case Op::DIV:           return a-&gt;Eval() / b-&gt;Eval();

        case Op::NEGATE:        return -(a-&gt;Eval());
        case Op::SQRT:          return sqrt(a-&gt;Eval());
        case Op::SQUARE:        { double r = a-&gt;Eval(); return r*r; }
        case Op::SIN:           return sin(a-&gt;Eval());
        case Op::COS:           return cos(a-&gt;Eval());
        case Op::ACOS:          return acos(a-&gt;Eval());
        case Op::ASIN:          return asin(a-&gt;Eval());
    }
    ssassert(false, "Unexpected operation");
}

Expr *Expr::PartialWrt(hParam p) const {
    Expr *da, *db;

    switch(op) {
        case Op::PARAM_PTR: return From(p.v == parp-&gt;h.v ? 1 : 0);
        case Op::PARAM:     return From(p.v == parh.v ? 1 : 0);

        case Op::CONSTANT:  return From(0.0);
        case Op::VARIABLE:  ssassert(false, "Not supported yet");

        case Op::PLUS:      return (a-&gt;PartialWrt(p))-&gt;Plus(b-&gt;PartialWrt(p));
        case Op::MINUS:     return (a-&gt;PartialWrt(p))-&gt;Minus(b-&gt;PartialWrt(p));

        case Op::TIMES:
            da = a-&gt;PartialWrt(p);
            db = b-&gt;PartialWrt(p);
            return (a-&gt;Times(db))-&gt;Plus(b-&gt;Times(da));

        case Op::DIV:
            da = a-&gt;PartialWrt(p);
            db = b-&gt;PartialWrt(p);
            return ((da-&gt;Times(b))-&gt;Minus(a-&gt;Times(db)))-&gt;Div(b-&gt;Square());

        case Op::SQRT:
            return (From(0.5)-&gt;Div(a-&gt;Sqrt()))-&gt;Times(a-&gt;PartialWrt(p));

        case Op::SQUARE:
            return (From(2.0)-&gt;Times(a))-&gt;Times(a-&gt;PartialWrt(p));

        case Op::NEGATE:    return (a-&gt;PartialWrt(p))-&gt;Negate();
        case Op::SIN:       return (a-&gt;Cos())-&gt;Times(a-&gt;PartialWrt(p));
        case Op::COS:       return ((a-&gt;Sin())-&gt;Times(a-&gt;PartialWrt(p)))-&gt;Negate();

        case Op::ASIN:
            return (From(1)-&gt;Div((From(1)-&gt;Minus(a-&gt;Square()))-&gt;Sqrt()))
                        -&gt;Times(a-&gt;PartialWrt(p));
        case Op::ACOS:
            return (From(-1)-&gt;Div((From(1)-&gt;Minus(a-&gt;Square()))-&gt;Sqrt()))
                        -&gt;Times(a-&gt;PartialWrt(p));
    }
    ssassert(false, "Unexpected operation");
}

uint64_t Expr::ParamsUsed() const {
    uint64_t r = 0;
    if(op == Op::PARAM)     r |= ((uint64_t)1 &lt;&lt; (parh.v % 61));
    if(op == Op::PARAM_PTR) r |= ((uint64_t)1 &lt;&lt; (parp-&gt;h.v % 61));

    int c = Children();
    if(c &gt;= 1)          r |= a-&gt;ParamsUsed();
    if(c &gt;= 2)          r |= b-&gt;ParamsUsed();
    return r;
}

</t>
<t tx="leo.20171226104022.37">bool Expr::DependsOn(hParam p) const {
    if(op == Op::PARAM)     return (parh.v    == p.v);
    if(op == Op::PARAM_PTR) return (parp-&gt;h.v == p.v);

    int c = Children();
    if(c == 1)          return a-&gt;DependsOn(p);
    if(c == 2)          return a-&gt;DependsOn(p) || b-&gt;DependsOn(p);
    return false;
}

</t>
<t tx="leo.20171226104022.38">bool Expr::Tol(double a, double b) {
    return fabs(a - b) &lt; 0.001;
}
Expr *Expr::FoldConstants() {
    Expr *n = AllocExpr();
    *n = *this;

    int c = Children();
    if(c &gt;= 1) n-&gt;a = a-&gt;FoldConstants();
    if(c &gt;= 2) n-&gt;b = b-&gt;FoldConstants();

    switch(op) {
        case Op::PARAM_PTR:
        case Op::PARAM:
        case Op::CONSTANT:
        case Op::VARIABLE:
            break;

        case Op::MINUS:
        case Op::TIMES:
        case Op::DIV:
        case Op::PLUS:
            // If both ops are known, then we can evaluate immediately
            if(n-&gt;a-&gt;op == Op::CONSTANT &amp;&amp; n-&gt;b-&gt;op == Op::CONSTANT) {
                double nv = n-&gt;Eval();
                n-&gt;op = Op::CONSTANT;
                n-&gt;v = nv;
                break;
            }
            // x + 0 = 0 + x = x
            if(op == Op::PLUS &amp;&amp; n-&gt;b-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;b-&gt;v, 0)) {
                *n = *(n-&gt;a); break;
            }
            if(op == Op::PLUS &amp;&amp; n-&gt;a-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;a-&gt;v, 0)) {
                *n = *(n-&gt;b); break;
            }
            // 1*x = x*1 = x
            if(op == Op::TIMES &amp;&amp; n-&gt;b-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;b-&gt;v, 1)) {
                *n = *(n-&gt;a); break;
            }
            if(op == Op::TIMES &amp;&amp; n-&gt;a-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;a-&gt;v, 1)) {
                *n = *(n-&gt;b); break;
            }
            // 0*x = x*0 = 0
            if(op == Op::TIMES &amp;&amp; n-&gt;b-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;b-&gt;v, 0)) {
                n-&gt;op = Op::CONSTANT; n-&gt;v = 0; break;
            }
            if(op == Op::TIMES &amp;&amp; n-&gt;a-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;a-&gt;v, 0)) {
                n-&gt;op = Op::CONSTANT; n-&gt;v = 0; break;
            }

            break;

        case Op::SQRT:
        case Op::SQUARE:
        case Op::NEGATE:
        case Op::SIN:
        case Op::COS:
        case Op::ASIN:
        case Op::ACOS:
            if(n-&gt;a-&gt;op == Op::CONSTANT) {
                double nv = n-&gt;Eval();
                n-&gt;op = Op::CONSTANT;
                n-&gt;v = nv;
            }
            break;
    }
    return n;
}

</t>
<t tx="leo.20171226104022.39">void Expr::Substitute(hParam oldh, hParam newh) {
    ssassert(op != Op::PARAM_PTR, "Expected an expression that refer to params via handles");

    if(op == Op::PARAM &amp;&amp; parh.v == oldh.v) {
        parh = newh;
    }
    int c = Children();
    if(c &gt;= 1) a-&gt;Substitute(oldh, newh);
    if(c &gt;= 2) b-&gt;Substitute(oldh, newh);
}

//-----------------------------------------------------------------------------
// If the expression references only one parameter that appears in pl, then
// return that parameter. If no param is referenced, then return NO_PARAMS.
// If multiple params are referenced, then return MULTIPLE_PARAMS.
//-----------------------------------------------------------------------------
const hParam Expr::NO_PARAMS       = { 0 };
const hParam Expr::MULTIPLE_PARAMS = { 1 };
hParam Expr::ReferencedParams(ParamList *pl) const {
    if(op == Op::PARAM) {
        if(pl-&gt;FindByIdNoOops(parh)) {
            return parh;
        } else {
            return NO_PARAMS;
        }
    }
    ssassert(op != Op::PARAM_PTR, "Expected an expression that refer to params via handles");

    int c = Children();
    if(c == 0) {
        return NO_PARAMS;
    } else if(c == 1) {
        return a-&gt;ReferencedParams(pl);
    } else if(c == 2) {
        hParam pa, pb;
        pa = a-&gt;ReferencedParams(pl);
        pb = b-&gt;ReferencedParams(pl);
        if(pa.v == NO_PARAMS.v) {
            return pb;
        } else if(pb.v == NO_PARAMS.v) {
            return pa;
        } else if(pa.v == pb.v) {
            return pa; // either, doesn't matter
        } else {
            return MULTIPLE_PARAMS;
        }
    } else ssassert(false, "Unexpected children count");
}


//-----------------------------------------------------------------------------
// Routines to pretty-print an expression. Mostly for debugging.
//-----------------------------------------------------------------------------

std::string Expr::Print() const {
    char c;
    switch(op) {
        case Op::PARAM:     return ssprintf("param(%08x)", parh.v);
        case Op::PARAM_PTR: return ssprintf("param(p%08x)", parp-&gt;h.v);

        case Op::CONSTANT:  return ssprintf("%.3f", v);
        case Op::VARIABLE:  return "(var)";

        case Op::PLUS:      c = '+'; goto p;
        case Op::MINUS:     c = '-'; goto p;
        case Op::TIMES:     c = '*'; goto p;
        case Op::DIV:       c = '/'; goto p;
p:
            return "(" + a-&gt;Print() + " " + c + " " + b-&gt;Print() + ")";
            break;

        case Op::NEGATE:    return "(- " + a-&gt;Print() + ")";
        case Op::SQRT:      return "(sqrt " + a-&gt;Print() + ")";
        case Op::SQUARE:    return "(square " + a-&gt;Print() + ")";
        case Op::SIN:       return "(sin " + a-&gt;Print() + ")";
        case Op::COS:       return "(cos " + a-&gt;Print() + ")";
        case Op::ASIN:      return "(asin " + a-&gt;Print() + ")";
        case Op::ACOS:      return "(acos " + a-&gt;Print() + ")";
    }
    ssassert(false, "Unexpected operation");
}


//-----------------------------------------------------------------------------
// A parser; convert a string to an expression. Infix notation, with the
// usual shift/reduce approach. I had great hopes for user-entered eq
// constraints, but those don't seem very useful, so right now this is just
// to provide calculator type functionality wherever numbers are entered.
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20171226104022.4">                                     bool other, bool other2)
{
    Constraint c = {};
    c.group = SS.GW.activeGroup;
    c.workplane = SS.GW.ActiveWorkplane();
    c.type = type;
    c.ptA = ptA;
    c.ptB = ptB;
    c.entityA = entityA;
    c.entityB = entityB;
    c.other = other;
    c.other2 = other2;
    return AddConstraint(&amp;c, /*rememberForUndo=*/false);
}

hConstraint Constraint::Constrain(Constraint::Type type, hEntity ptA, hEntity ptB, hEntity entityA){
    return Constrain(type, ptA, ptB, entityA, Entity::NO_ENTITY, /*other=*/false, /*other2=*/false);
}

hConstraint Constraint::ConstrainCoincident(hEntity ptA, hEntity ptB) {
    return Constrain(Type::POINTS_COINCIDENT, ptA, ptB,
        Entity::NO_ENTITY, Entity::NO_ENTITY, /*other=*/false, /*other2=*/false);
}

</t>
<t tx="leo.20171226104022.40">class ExprParser {
public:
    enum class TokenType {
        ERROR = 0,

        PAREN_LEFT,
        PAREN_RIGHT,
        BINARY_OP,
        UNARY_OP,
        OPERAND,

        END,
    };

    @others
};

ExprParser::Token ExprParser::Token::From(TokenType type, Expr *expr) {
    Token t;
    t.type = type;
    t.expr = expr;
    return t;
}

ExprParser::Token ExprParser::Token::From(TokenType type, Expr::Op op) {
    Token t;
    t.type = type;
    t.expr = Expr::AllocExpr();
    t.expr-&gt;op = op;
    return t;
}

</t>
<t tx="leo.20171226104022.41">class Token {
public:
    TokenType  type;
    Expr      *expr;

    static Token From(TokenType type = TokenType::ERROR, Expr *expr = NULL);
    static Token From(TokenType type, Expr::Op op);
    bool IsError() const { return type == TokenType::ERROR; }
};

const char        *input;
unsigned           inputPos;
std::vector&lt;Token&gt; stack;

char ReadChar();
char PeekChar();

std::string ReadWord();
void SkipSpace();

Token PopOperator(std::string *error);
Token PopOperand(std::string *error);

int Precedence(Token token);
Token LexNumber(std::string *error);
Token Lex(std::string *error);
bool Reduce(std::string *error);
bool Parse(std::string *error, size_t reduceUntil = 0);

static Expr *Parse(const char *input, std::string *error);
</t>
<t tx="leo.20171226104022.42">char ExprParser::ReadChar() {
    return input[inputPos++];
}

</t>
<t tx="leo.20171226104022.43">char ExprParser::PeekChar() {
    return input[inputPos];
}

std::string ExprParser::ReadWord() {
    std::string s;

    while(char c = PeekChar()) {
        if(!isalnum(c)) break;
        s.push_back(ReadChar());
    }

    return s;
}

</t>
<t tx="leo.20171226104022.44">void ExprParser::SkipSpace() {
    while(char c = PeekChar()) {
        if(!isspace(c)) break;
        ReadChar();
    }
}

ExprParser::Token ExprParser::LexNumber(std::string *error) {
    std::string s;

    while(char c = PeekChar()) {
        if(!((c &gt;= '0' &amp;&amp; c &lt;= '9') || c == 'e' || c == 'E' || c == '.' || c == '_')) break;
        if(c == '_') {
            ReadChar();
            continue;
        }
        s.push_back(ReadChar());
    }

    char *endptr;
    double d = strtod(s.c_str(), &amp;endptr);

    Token t = Token::From();
    if(endptr == s.c_str() + s.size()) {
        t = Token::From(TokenType::OPERAND, Expr::Op::CONSTANT);
        t.expr-&gt;v = d;
    } else {
        *error = "'" + s + "' is not a valid number";
    }
    return t;
}

ExprParser::Token ExprParser::Lex(std::string *error) {
    SkipSpace();

    Token t = Token::From();
    char c = PeekChar();
    if(isupper(c)) {
        std::string n = ReadWord();
        t = Token::From(TokenType::OPERAND, Expr::Op::VARIABLE);
    } else if(isalpha(c)) {
        std::string s = ReadWord();
        if(s == "sqrt") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::SQRT);
        } else if(s == "square") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::SQUARE);
        } else if(s == "sin") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::SIN);
        } else if(s == "cos") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::COS);
        } else if(s == "asin") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::ASIN);
        } else if(s == "acos") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::ACOS);
        } else if(s == "pi") {
            t = Token::From(TokenType::OPERAND, Expr::Op::CONSTANT);
            t.expr-&gt;v = PI;
        } else {
            *error = "'" + s + "' is not a valid variable, function or constant";
        }
    } else if(isdigit(c) || c == '.') {
        return LexNumber(error);
    } else if(ispunct(c)) {
        ReadChar();
        if(c == '+') {
            t = Token::From(TokenType::BINARY_OP, Expr::Op::PLUS);
        } else if(c == '-') {
            t = Token::From(TokenType::BINARY_OP, Expr::Op::MINUS);
        } else if(c == '*') {
            t = Token::From(TokenType::BINARY_OP, Expr::Op::TIMES);
        } else if(c == '/') {
            t = Token::From(TokenType::BINARY_OP, Expr::Op::DIV);
        } else if(c == '(') {
            t = Token::From(TokenType::PAREN_LEFT);
        } else if(c == ')') {
            t = Token::From(TokenType::PAREN_RIGHT);
        } else {
            *error = "'" + std::string(1, c) + "' is not a valid operator";
        }
    } else if(c == '\0') {
        t = Token::From(TokenType::END);
    } else {
        *error = "Unexpected character '" + std::string(1, c) + "'";
    }

    return t;
}

ExprParser::Token ExprParser::PopOperand(std::string *error) {
    Token t = Token::From();
    if(stack.empty() || stack.back().type != TokenType::OPERAND) {
        *error = "Expected an operand";
    } else {
        t = stack.back();
        stack.pop_back();
    }
    return t;
}

ExprParser::Token ExprParser::PopOperator(std::string *error) {
    Token t = Token::From();
    if(stack.empty() || (stack.back().type != TokenType::UNARY_OP &amp;&amp;
                         stack.back().type != TokenType::BINARY_OP)) {
        *error = "Expected an operator";
    } else {
        t = stack.back();
        stack.pop_back();
    }
    return t;
}

</t>
<t tx="leo.20171226104022.45">int ExprParser::Precedence(Token t) {
    ssassert(t.type == TokenType::BINARY_OP ||
             t.type == TokenType::UNARY_OP ||
             t.type == TokenType::OPERAND,
             "Unexpected token type");

    if(t.type == TokenType::UNARY_OP) {
        return 30;
    } else if(t.expr-&gt;op == Expr::Op::TIMES ||
              t.expr-&gt;op == Expr::Op::DIV) {
        return 20;
    } else if(t.expr-&gt;op == Expr::Op::PLUS ||
              t.expr-&gt;op == Expr::Op::MINUS) {
        return 10;
    } else if(t.type == TokenType::OPERAND) {
        return 0;
    } else ssassert(false, "Unexpected operator");
}

</t>
<t tx="leo.20171226104022.46">bool ExprParser::Reduce(std::string *error) {
    Token a = PopOperand(error);
    if(a.IsError()) return false;

    Token op = PopOperator(error);
    if(op.IsError()) return false;

    Token r = Token::From(TokenType::OPERAND);
    switch(op.type) {
        case TokenType::BINARY_OP: {
            Token b = PopOperand(error);
            if(b.IsError()) return false;
            r.expr = b.expr-&gt;AnyOp(op.expr-&gt;op, a.expr);
            break;
        }

        case TokenType::UNARY_OP: {
            Expr *e = a.expr;
            switch(op.expr-&gt;op) {
                case Expr::Op::NEGATE: e = e-&gt;Negate(); break;
                case Expr::Op::SQRT:   e = e-&gt;Sqrt(); break;
                case Expr::Op::SQUARE: e = e-&gt;Times(e); break;
                case Expr::Op::SIN:    e = e-&gt;Times(Expr::From(PI/180))-&gt;Sin(); break;
                case Expr::Op::COS:    e = e-&gt;Times(Expr::From(PI/180))-&gt;Cos(); break;
                case Expr::Op::ASIN:   e = e-&gt;ASin()-&gt;Times(Expr::From(180/PI)); break;
                case Expr::Op::ACOS:   e = e-&gt;ACos()-&gt;Times(Expr::From(180/PI)); break;
                default: ssassert(false, "Unexpected unary operator");
            }
            r.expr = e;
            break;
        }

        default: ssassert(false, "Unexpected operator");
    }
    stack.push_back(r);

    return true;
}

</t>
<t tx="leo.20171226104022.47">bool ExprParser::Parse(std::string *error, size_t reduceUntil) {
    while(true) {
        Token t = Lex(error);
        switch(t.type) {
            case TokenType::ERROR:
                return false;

            case TokenType::END:
            case TokenType::PAREN_RIGHT:
                while(stack.size() &gt; 1 + reduceUntil) {
                    if(!Reduce(error)) return false;
                }

                if(t.type == TokenType::PAREN_RIGHT) {
                    stack.push_back(t);
                }
                return true;

            case TokenType::PAREN_LEFT: {
                // sub-expression
                if(!Parse(error, /*reduceUntil=*/stack.size())) return false;

                if(stack.empty() || stack.back().type != TokenType::PAREN_RIGHT) {
                    *error = "Expected ')'";
                    return false;
                }
                stack.pop_back();
                break;
            }

            case TokenType::BINARY_OP:
                if((stack.size() &gt; reduceUntil &amp;&amp; stack.back().type != TokenType::OPERAND) ||
                   stack.size() == reduceUntil) {
                    if(t.expr-&gt;op == Expr::Op::MINUS) {
                        t.type = TokenType::UNARY_OP;
                        t.expr-&gt;op = Expr::Op::NEGATE;
                        stack.push_back(t);
                        break;
                    }
                }

                while(stack.size() &gt; 1 + reduceUntil &amp;&amp;
                      Precedence(t) &lt;= Precedence(stack[stack.size() - 2])) {
                    if(!Reduce(error)) return false;
                }

                stack.push_back(t);
                break;

            case TokenType::UNARY_OP:
            case TokenType::OPERAND:
                stack.push_back(t);
                break;
        }
    }

    return true;
}

Expr *ExprParser::Parse(const char *input, std::string *error) {
    ExprParser parser;
    parser.input    = input;
    parser.inputPos = 0;
    if(!parser.Parse(error)) return NULL;

    Token r = parser.PopOperand(error);
    if(r.IsError()) return NULL;
    return r.expr;
}

Expr *Expr::Parse(const char *input, std::string *error) {
    return ExprParser::Parse(input, error);
}

Expr *Expr::From(const char *input, bool popUpError) {
    std::string error;
    Expr *e = ExprParser::Parse(input, &amp;error);
    if(!e) {
        dbp("Parse/lex error: %s", error.c_str());
        if(popUpError) {
            Error("Not a valid number or expression: '%s'.\n%s.", input, error.c_str());
        }
    }
    return e;
}
</t>
<t tx="leo.20171226104022.48">//-----------------------------------------------------------------------------
// A library wrapper around SolveSpace, to permit someone to use its constraint
// solver without coupling their program too much to SolveSpace's internals.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"
#define EXPORT_DLL
#include &lt;slvs.h&gt;

Sketch SolveSpace::SK = {};
static System SYS;

static int IsInit = 0;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20171226104022.49">void Group::GenerateEquations(IdList&lt;Equation,hEquation&gt; *) {
    // Nothing to do for now.
}

</t>
<t tx="leo.20171226104022.5">void Constraint::MenuConstrain(Command id) {
    Constraint c = {};
    c.group = SS.GW.activeGroup;
    c.workplane = SS.GW.ActiveWorkplane();

    SS.GW.GroupSelection();
    auto const &amp;gs = SS.GW.gs;

    switch(id) {
        case Command::DISTANCE_DIA:
        case Command::REF_DISTANCE: {
            if(gs.points == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_PT_DISTANCE;
                c.ptA = gs.point[0];
                c.ptB = gs.point[1];
            } else if(gs.lineSegments == 1 &amp;&amp; gs.n == 1) {
                c.type = Type::PT_PT_DISTANCE;
                Entity *e = SK.GetEntity(gs.entity[0]);
                c.ptA = e-&gt;point[0];
                c.ptB = e-&gt;point[1];
            } else if(gs.vectors == 1 &amp;&amp; gs.points == 2 &amp;&amp; gs.n == 3) {
                c.type = Type::PROJ_PT_DISTANCE;
                c.ptA = gs.point[0];
                c.ptB = gs.point[1];
                c.entityA = gs.vector[0];
            } else if(gs.workplanes == 1 &amp;&amp; gs.points == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_PLANE_DISTANCE;
                c.ptA = gs.point[0];
                c.entityA = gs.entity[0];
            } else if(gs.lineSegments == 1 &amp;&amp; gs.points == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_LINE_DISTANCE;
                c.ptA = gs.point[0];
                c.entityA = gs.entity[0];
            } else if(gs.faces == 1 &amp;&amp; gs.points == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_FACE_DISTANCE;
                c.ptA = gs.point[0];
                c.entityA = gs.face[0];
            } else if(gs.circlesOrArcs == 1 &amp;&amp; gs.n == 1) {
                c.type = Type::DIAMETER;
                c.entityA = gs.entity[0];
            } else {
                Error(_("Bad selection for distance / diameter constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two points (distance between points)\n"
                        "    * a line segment (length)\n"
                        "    * two points and a line segment or normal (projected distance)\n"
                        "    * a workplane and a point (minimum distance)\n"
                        "    * a line segment and a point (minimum distance)\n"
                        "    * a plane face and a point (minimum distance)\n"
                        "    * a circle or an arc (diameter)\n"));
                return;
            }
            if(c.type == Type::PT_PT_DISTANCE || c.type == Type::PROJ_PT_DISTANCE) {
                Vector n = SS.GW.projRight.Cross(SS.GW.projUp);
                Vector a = SK.GetEntity(c.ptA)-&gt;PointGetNum();
                Vector b = SK.GetEntity(c.ptB)-&gt;PointGetNum();
                c.disp.offset = n.Cross(a.Minus(b));
                c.disp.offset = (c.disp.offset).WithMagnitude(50/SS.GW.scale);
            } else {
                c.disp.offset = Vector::From(0, 0, 0);
            }

            if(id == Command::REF_DISTANCE) {
                c.reference = true;
            }

            c.valA = 0;
            c.ModifyToSatisfy();
            AddConstraint(&amp;c);
            break;
        }

        case Command::ON_ENTITY:
            if(gs.points == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::POINTS_COINCIDENT;
                c.ptA = gs.point[0];
                c.ptB = gs.point[1];
            } else if(gs.points == 1 &amp;&amp; gs.workplanes == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_IN_PLANE;
                c.ptA = gs.point[0];
                c.entityA = gs.entity[0];
            } else if(gs.points == 1 &amp;&amp; gs.lineSegments == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_ON_LINE;
                c.ptA = gs.point[0];
                c.entityA = gs.entity[0];
            } else if(gs.points == 1 &amp;&amp; gs.circlesOrArcs == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_ON_CIRCLE;
                c.ptA = gs.point[0];
                c.entityA = gs.entity[0];
            } else if(gs.points == 1 &amp;&amp; gs.faces == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_ON_FACE;
                c.ptA = gs.point[0];
                c.entityA = gs.face[0];
            } else {
                Error(_("Bad selection for on point / curve / plane constraint. "
                        "This constraint can apply to:\n\n"
                        "    * two points (points coincident)\n"
                        "    * a point and a workplane (point in plane)\n"
                        "    * a point and a line segment (point on line)\n"
                        "    * a point and a circle or arc (point on curve)\n"
                        "    * a point and a plane face (point on face)\n"));
                return;
            }
            AddConstraint(&amp;c);
            break;

        case Command::EQUAL:
            if(gs.lineSegments == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::EQUAL_LENGTH_LINES;
                c.entityA = gs.entity[0];
                c.entityB = gs.entity[1];
            } else if(gs.lineSegments == 2 &amp;&amp; gs.points == 2 &amp;&amp; gs.n == 4) {
                c.type = Type::EQ_PT_LN_DISTANCES;
                c.entityA = gs.entity[0];
                c.ptA = gs.point[0];
                c.entityB = gs.entity[1];
                c.ptB = gs.point[1];
            } else if(gs.lineSegments == 1 &amp;&amp; gs.points == 2 &amp;&amp; gs.n == 3) {
                // The same line segment for the distances, but different
                // points.
                c.type = Type::EQ_PT_LN_DISTANCES;
                c.entityA = gs.entity[0];
                c.ptA = gs.point[0];
                c.entityB = gs.entity[0];
                c.ptB = gs.point[1];
            } else if(gs.lineSegments == 2 &amp;&amp; gs.points == 1 &amp;&amp; gs.n == 3) {
                c.type = Type::EQ_LEN_PT_LINE_D;
                c.entityA = gs.entity[0];
                c.entityB = gs.entity[1];
                c.ptA = gs.point[0];
            } else if(gs.vectors == 4 &amp;&amp; gs.n == 4) {
                c.type = Type::EQUAL_ANGLE;
                c.entityA = gs.vector[0];
                c.entityB = gs.vector[1];
                c.entityC = gs.vector[2];
                c.entityD = gs.vector[3];
            } else if(gs.vectors == 3 &amp;&amp; gs.n == 3) {
                c.type = Type::EQUAL_ANGLE;
                c.entityA = gs.vector[0];
                c.entityB = gs.vector[1];
                c.entityC = gs.vector[1];
                c.entityD = gs.vector[2];
            } else if(gs.circlesOrArcs == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::EQUAL_RADIUS;
                c.entityA = gs.entity[0];
                c.entityB = gs.entity[1];
            } else if(gs.arcs == 1 &amp;&amp; gs.lineSegments == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::EQUAL_LINE_ARC_LEN;
                if(SK.GetEntity(gs.entity[0])-&gt;type == Entity::Type::ARC_OF_CIRCLE) {
                    c.entityA = gs.entity[1];
                    c.entityB = gs.entity[0];
                } else {
                    c.entityA = gs.entity[0];
                    c.entityB = gs.entity[1];
                }
            } else {
                Error(_("Bad selection for equal length / radius constraint. "
                        "This constraint can apply to:\n\n"
                        "    * two line segments (equal length)\n"
                        "    * two line segments and two points "
                                "(equal point-line distances)\n"
                        "    * a line segment and two points "
                                "(equal point-line distances)\n"
                        "    * a line segment, and a point and line segment "
                                "(point-line distance equals length)\n"
                        "    * four line segments or normals "
                                "(equal angle between A,B and C,D)\n"
                        "    * three line segments or normals "
                                "(equal angle between A,B and B,C)\n"
                        "    * two circles or arcs (equal radius)\n"
                        "    * a line segment and an arc "
                                "(line segment length equals arc length)\n"));
                return;
            }
            if(c.type == Type::EQUAL_ANGLE) {
                // Infer the nearest supplementary angle from the sketch.
                Vector a1 = SK.GetEntity(c.entityA)-&gt;VectorGetNum(),
                       b1 = SK.GetEntity(c.entityB)-&gt;VectorGetNum(),
                       a2 = SK.GetEntity(c.entityC)-&gt;VectorGetNum(),
                       b2 = SK.GetEntity(c.entityD)-&gt;VectorGetNum();
                double d1 = a1.Dot(b1), d2 = a2.Dot(b2);

                if(d1*d2 &lt; 0) {
                    c.other = true;
                }
            }
            AddConstraint(&amp;c);
            break;

        case Command::RATIO:
            if(gs.lineSegments == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::LENGTH_RATIO;
                c.entityA = gs.entity[0];
                c.entityB = gs.entity[1];
            } else {
                Error(_("Bad selection for length ratio constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two line segments\n"));
                return;
            }

            c.valA = 0;
            c.ModifyToSatisfy();
            AddConstraint(&amp;c);
            break;

        case Command::DIFFERENCE:
            if(gs.lineSegments == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::LENGTH_DIFFERENCE;
                c.entityA = gs.entity[0];
                c.entityB = gs.entity[1];
            } else {
                Error(_("Bad selection for length difference constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two line segments\n"));
                return;
            }

            c.valA = 0;
            c.ModifyToSatisfy();
            AddConstraint(&amp;c);
            break;

        case Command::AT_MIDPOINT:
            if(gs.lineSegments == 1 &amp;&amp; gs.points == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::AT_MIDPOINT;
                c.entityA = gs.entity[0];
                c.ptA = gs.point[0];

                // If a point is at-midpoint, then no reason to also constrain
                // it on-line; so auto-remove that.
                DeleteAllConstraintsFor(Type::PT_ON_LINE, c.entityA, c.ptA);
            } else if(gs.lineSegments == 1 &amp;&amp; gs.workplanes == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::AT_MIDPOINT;
                int i = SK.GetEntity(gs.entity[0])-&gt;IsWorkplane() ? 1 : 0;
                c.entityA = gs.entity[i];
                c.entityB = gs.entity[1-i];
            } else {
                Error(_("Bad selection for at midpoint constraint. This "
                        "constraint can apply to:\n\n"
                        "    * a line segment and a point "
                              "(point at midpoint)\n"
                        "    * a line segment and a workplane "
                              "(line's midpoint on plane)\n"));
                return;
            }
            AddConstraint(&amp;c);
            break;

        case Command::SYMMETRIC:
            if(gs.points == 2 &amp;&amp;
                                ((gs.workplanes == 1 &amp;&amp; gs.n == 3) ||
                                 (gs.n == 2)))
            {
                if(gs.entities &gt; 0)
                    c.entityA = gs.entity[0];
                c.ptA = gs.point[0];
                c.ptB = gs.point[1];
                c.type = Type::SYMMETRIC;
            } else if(gs.lineSegments == 1 &amp;&amp;
                                ((gs.workplanes == 1 &amp;&amp; gs.n == 2) ||
                                 (gs.n == 1)))
            {
                Entity *line;
                if(SK.GetEntity(gs.entity[0])-&gt;IsWorkplane()) {
                    line = SK.GetEntity(gs.entity[1]);
                    c.entityA = gs.entity[0];
                } else {
                    line = SK.GetEntity(gs.entity[0]);
                }
                c.ptA = line-&gt;point[0];
                c.ptB = line-&gt;point[1];
                c.type = Type::SYMMETRIC;
            } else if(SS.GW.LockedInWorkplane()
                        &amp;&amp; gs.lineSegments == 2 &amp;&amp; gs.n == 2)
            {
                Entity *l0 = SK.GetEntity(gs.entity[0]),
                       *l1 = SK.GetEntity(gs.entity[1]);

                if((l1-&gt;group.v != SS.GW.activeGroup.v) ||
                   (l1-&gt;construction &amp;&amp; !(l0-&gt;construction)))
                {
                    swap(l0, l1);
                }
                c.ptA = l1-&gt;point[0];
                c.ptB = l1-&gt;point[1];
                c.entityA = l0-&gt;h;
                c.type = Type::SYMMETRIC_LINE;
            } else if(SS.GW.LockedInWorkplane()
                        &amp;&amp; gs.lineSegments == 1 &amp;&amp; gs.points == 2 &amp;&amp; gs.n == 3)
            {
                c.ptA = gs.point[0];
                c.ptB = gs.point[1];
                c.entityA = gs.entity[0];
                c.type = Type::SYMMETRIC_LINE;
            } else {
                Error(_("Bad selection for symmetric constraint. This constraint "
                        "can apply to:\n\n"
                        "    * two points or a line segment "
                            "(symmetric about workplane's coordinate axis)\n"
                        "    * line segment, and two points or a line segment "
                            "(symmetric about line segment)\n"
                        "    * workplane, and two points or a line segment "
                            "(symmetric about workplane)\n"));
                return;
            }
            if(c.entityA.v == Entity::NO_ENTITY.v) {
                // Horizontal / vertical symmetry, implicit symmetry plane
                // normal to the workplane
                if(c.workplane.v == Entity::FREE_IN_3D.v) {
                    Error(_("A workplane must be active when constraining "
                            "symmetric without an explicit symmetry plane."));
                    return;
                }
                Vector pa = SK.GetEntity(c.ptA)-&gt;PointGetNum();
                Vector pb = SK.GetEntity(c.ptB)-&gt;PointGetNum();
                Vector dp = pa.Minus(pb);
                EntityBase *norm = SK.GetEntity(c.workplane)-&gt;Normal();;
                Vector u = norm-&gt;NormalU(), v = norm-&gt;NormalV();
                if(fabs(dp.Dot(u)) &gt; fabs(dp.Dot(v))) {
                    c.type = Type::SYMMETRIC_HORIZ;
                } else {
                    c.type = Type::SYMMETRIC_VERT;
                }
                if(gs.lineSegments == 1) {
                    // If this line segment is already constrained horiz or
                    // vert, then auto-remove that redundant constraint.
                    DeleteAllConstraintsFor(Type::HORIZONTAL, (gs.entity[0]),
                        Entity::NO_ENTITY);
                    DeleteAllConstraintsFor(Type::VERTICAL, (gs.entity[0]),
                        Entity::NO_ENTITY);
                }
            }
            AddConstraint(&amp;c);
            break;

        case Command::VERTICAL:
        case Command::HORIZONTAL: {
            hEntity ha, hb;
            if(c.workplane.v == Entity::FREE_IN_3D.v) {
                Error(_("Activate a workplane (with Sketch -&gt; In Workplane) before "
                        "applying a horizontal or vertical constraint."));
                return;
            }
            if(gs.lineSegments == 1 &amp;&amp; gs.n == 1) {
                c.entityA = gs.entity[0];
                Entity *e = SK.GetEntity(c.entityA);
                ha = e-&gt;point[0];
                hb = e-&gt;point[1];
            } else if(gs.points == 2 &amp;&amp; gs.n == 2) {
                ha = c.ptA = gs.point[0];
                hb = c.ptB = gs.point[1];
            } else {
                Error(_("Bad selection for horizontal / vertical constraint. "
                        "This constraint can apply to:\n\n"
                        "    * two points\n"
                        "    * a line segment\n"));
                return;
            }
            if(id == Command::HORIZONTAL) {
                c.type = Type::HORIZONTAL;
            } else {
                c.type = Type::VERTICAL;
            }
            AddConstraint(&amp;c);
            break;
        }

        case Command::ORIENTED_SAME: {
            if(gs.anyNormals == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::SAME_ORIENTATION;
                c.entityA = gs.anyNormal[0];
                c.entityB = gs.anyNormal[1];
            } else {
                Error(_("Bad selection for same orientation constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two normals\n"));
                return;
            }
            SS.UndoRemember();

            Entity *nfree = SK.GetEntity(c.entityA);
            Entity *nref  = SK.GetEntity(c.entityB);
            if(nref-&gt;group.v == SS.GW.activeGroup.v) {
                swap(nref, nfree);
            }
            if(nfree-&gt;group.v == SS.GW.activeGroup.v &amp;&amp;
               nref -&gt;group.v != SS.GW.activeGroup.v)
            {
                // nfree is free, and nref is locked (since it came from a
                // previous group); so let's force nfree aligned to nref,
                // and make convergence easy
                Vector ru = nref -&gt;NormalU(), rv = nref -&gt;NormalV();
                Vector fu = nfree-&gt;NormalU(), fv = nfree-&gt;NormalV();

                if(fabs(fu.Dot(ru)) &lt; fabs(fu.Dot(rv))) {
                    // There might be an odd*90 degree rotation about the
                    // normal vector; allow that, since the numerical
                    // constraint does
                    swap(ru, rv);
                }
                fu = fu.Dot(ru) &gt; 0 ? ru : ru.ScaledBy(-1);
                fv = fv.Dot(rv) &gt; 0 ? rv : rv.ScaledBy(-1);

                nfree-&gt;NormalForceTo(Quaternion::From(fu, fv));
            }
            AddConstraint(&amp;c, /*rememberForUndo=*/false);
            break;
        }

        case Command::OTHER_ANGLE:
            if(gs.constraints == 1 &amp;&amp; gs.n == 0) {
                Constraint *c = SK.GetConstraint(gs.constraint[0]);
                if(c-&gt;type == Type::ANGLE) {
                    SS.UndoRemember();
                    c-&gt;other = !(c-&gt;other);
                    c-&gt;ModifyToSatisfy();
                    break;
                }
                if(c-&gt;type == Type::EQUAL_ANGLE) {
                    SS.UndoRemember();
                    c-&gt;other = !(c-&gt;other);
                    SS.MarkGroupDirty(c-&gt;group);
                    break;
                }
            }
            Error(_("Must select an angle constraint."));
            return;

        case Command::REFERENCE:
            if(gs.constraints == 1 &amp;&amp; gs.n == 0) {
                Constraint *c = SK.GetConstraint(gs.constraint[0]);
                if(c-&gt;HasLabel() &amp;&amp; c-&gt;type != Type::COMMENT) {
                    (c-&gt;reference) = !(c-&gt;reference);
                    SS.MarkGroupDirty(c-&gt;group, /*onlyThis=*/true);
                    break;
                }
            }
            Error(_("Must select a constraint with associated label."));
            return;

        case Command::ANGLE:
        case Command::REF_ANGLE: {
            if(gs.vectors == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::ANGLE;
                c.entityA = gs.vector[0];
                c.entityB = gs.vector[1];
                c.valA = 0;
            } else {
                Error(_("Bad selection for angle constraint. This constraint "
                        "can apply to:\n\n"
                        "    * two line segments\n"
                        "    * a line segment and a normal\n"
                        "    * two normals\n"));
                return;
            }

            Entity *ea = SK.GetEntity(c.entityA),
                   *eb = SK.GetEntity(c.entityB);
            if(ea-&gt;type == Entity::Type::LINE_SEGMENT &amp;&amp;
               eb-&gt;type == Entity::Type::LINE_SEGMENT)
            {
                Vector a0 = SK.GetEntity(ea-&gt;point[0])-&gt;PointGetNum(),
                       a1 = SK.GetEntity(ea-&gt;point[1])-&gt;PointGetNum(),
                       b0 = SK.GetEntity(eb-&gt;point[0])-&gt;PointGetNum(),
                       b1 = SK.GetEntity(eb-&gt;point[1])-&gt;PointGetNum();
                if(a0.Equals(b0) || a1.Equals(b1)) {
                    // okay, vectors should be drawn in same sense
                } else if(a0.Equals(b1) || a1.Equals(b0)) {
                    // vectors are in opposite sense
                    c.other = true;
                } else {
                    // no shared point; not clear which intersection to draw
                }
            }

            if(id == Command::REF_ANGLE) {
                c.reference = true;
            }

            c.ModifyToSatisfy();
            AddConstraint(&amp;c);
            break;
        }

        case Command::PARALLEL:
            if(gs.vectors == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::PARALLEL;
                c.entityA = gs.vector[0];
                c.entityB = gs.vector[1];
            } else if(gs.lineSegments == 1 &amp;&amp; gs.arcs == 1 &amp;&amp; gs.n == 2) {
                Entity *line = SK.GetEntity(gs.entity[0]);
                Entity *arc  = SK.GetEntity(gs.entity[1]);
                if(line-&gt;type == Entity::Type::ARC_OF_CIRCLE) {
                    swap(line, arc);
                }
                Vector l0 = SK.GetEntity(line-&gt;point[0])-&gt;PointGetNum(),
                       l1 = SK.GetEntity(line-&gt;point[1])-&gt;PointGetNum();
                Vector a1 = SK.GetEntity(arc-&gt;point[1])-&gt;PointGetNum(),
                       a2 = SK.GetEntity(arc-&gt;point[2])-&gt;PointGetNum();

                if(l0.Equals(a1) || l1.Equals(a1)) {
                    c.other = false;
                } else if(l0.Equals(a2) || l1.Equals(a2)) {
                    c.other = true;
                } else {
                    Error(_("The tangent arc and line segment must share an "
                            "endpoint. Constrain them with Constrain -&gt; "
                            "On Point before constraining tangent."));
                    return;
                }
                c.type = Type::ARC_LINE_TANGENT;
                c.entityA = arc-&gt;h;
                c.entityB = line-&gt;h;
            } else if(gs.lineSegments == 1 &amp;&amp; gs.cubics == 1 &amp;&amp; gs.n == 2) {
                Entity *line  = SK.GetEntity(gs.entity[0]);
                Entity *cubic = SK.GetEntity(gs.entity[1]);
                if(line-&gt;type == Entity::Type::CUBIC) {
                    swap(line, cubic);
                }
                Vector l0 = SK.GetEntity(line-&gt;point[0])-&gt;PointGetNum(),
                       l1 = SK.GetEntity(line-&gt;point[1])-&gt;PointGetNum();
                Vector as = cubic-&gt;CubicGetStartNum(),
                       af = cubic-&gt;CubicGetFinishNum();

                if(l0.Equals(as) || l1.Equals(as)) {
                    c.other = false;
                } else if(l0.Equals(af) || l1.Equals(af)) {
                    c.other = true;
                } else {
                    Error(_("The tangent cubic and line segment must share an "
                            "endpoint. Constrain them with Constrain -&gt; "
                            "On Point before constraining tangent."));
                    return;
                }
                c.type = Type::CUBIC_LINE_TANGENT;
                c.entityA = cubic-&gt;h;
                c.entityB = line-&gt;h;
            } else if(gs.cubics + gs.arcs == 2 &amp;&amp; gs.n == 2) {
                if(!SS.GW.LockedInWorkplane()) {
                    Error(_("Curve-curve tangency must apply in workplane."));
                    return;
                }
                Entity *eA = SK.GetEntity(gs.entity[0]),
                       *eB = SK.GetEntity(gs.entity[1]);
                Vector as = eA-&gt;EndpointStart(),
                       af = eA-&gt;EndpointFinish(),
                       bs = eB-&gt;EndpointStart(),
                       bf = eB-&gt;EndpointFinish();
                if(as.Equals(bs)) {
                    c.other = false; c.other2 = false;
                } else if(as.Equals(bf)) {
                    c.other = false; c.other2 = true;
                } else if(af.Equals(bs)) {
                    c.other = true; c.other2 = false;
                } else if(af.Equals(bf)) {
                    c.other = true; c.other2 = true;
                } else {
                    Error(_("The curves must share an endpoint. Constrain them "
                            "with Constrain -&gt; On Point before constraining "
                            "tangent."));
                    return;
                }
                c.type = Type::CURVE_CURVE_TANGENT;
                c.entityA = eA-&gt;h;
                c.entityB = eB-&gt;h;
            } else {
                Error(_("Bad selection for parallel / tangent constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two line segments (parallel)\n"
                        "    * a line segment and a normal (parallel)\n"
                        "    * two normals (parallel)\n"
                        "    * two line segments, arcs, or beziers, that share "
                              "an endpoint (tangent)\n"));
                return;
            }
            AddConstraint(&amp;c);
            break;

        case Command::PERPENDICULAR:
            if(gs.vectors == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::PERPENDICULAR;
                c.entityA = gs.vector[0];
                c.entityB = gs.vector[1];
            } else {
                Error(_("Bad selection for perpendicular constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two line segments\n"
                        "    * a line segment and a normal\n"
                        "    * two normals\n"));
                return;
            }
            AddConstraint(&amp;c);
            break;

        case Command::WHERE_DRAGGED:
            if(gs.points == 1 &amp;&amp; gs.n == 1) {
                c.type = Type::WHERE_DRAGGED;
                c.ptA = gs.point[0];
            } else {
                Error(_("Bad selection for lock point where dragged constraint. "
                        "This constraint can apply to:\n\n"
                        "    * a point\n"));
                return;
            }
            AddConstraint(&amp;c);
            break;

        case Command::COMMENT:
            SS.GW.pending.operation = GraphicsWindow::Pending::COMMAND;
            SS.GW.pending.command = Command::COMMENT;
            SS.GW.pending.description = _("click center of comment text");
            SS.ScheduleShowTW();
            break;

        default: ssassert(false, "Unexpected menu ID");
    }

    if(SK.constraint.FindByIdNoOops(c.h)) {
        Constraint *constraint = SK.GetConstraint(c.h);
        if(SS.TestRankForGroup(c.group) == SolveResult::REDUNDANT_OKAY &amp;&amp;
                !SK.GetGroup(SS.GW.activeGroup)-&gt;allowRedundant &amp;&amp;
                @others
}

#endif /* ! LIBRARY */
</t>
<t tx="leo.20171226104022.50">void SolveSpace::CnfFreezeInt(uint32_t, const std::string &amp;)
{
    abort();
}

uint32_t SolveSpace::CnfThawInt(uint32_t, const std::string &amp;)
{
    abort();
    return 0;
}

</t>
<t tx="leo.20171226104022.51">void SolveSpace::DoMessageBox(const char *, int, int, bool)
{
    abort();
}

</t>
<t tx="leo.20171226104022.52">extern "C" {

@others
} /* extern "C" */
</t>
<t tx="leo.20171226104022.53">void Slvs_QuaternionU(double qw, double qx, double qy, double qz,
                         double *x, double *y, double *z)
{
    Quaternion q = Quaternion::From(qw, qx, qy, qz);
    Vector v = q.RotationU();
    *x = v.x;
    *y = v.y;
    *z = v.z;
}

</t>
<t tx="leo.20171226104022.54">void Slvs_QuaternionV(double qw, double qx, double qy, double qz,
                         double *x, double *y, double *z)
{
    Quaternion q = Quaternion::From(qw, qx, qy, qz);
    Vector v = q.RotationV();
    *x = v.x;
    *y = v.y;
    *z = v.z;
}

</t>
<t tx="leo.20171226104022.55">void Slvs_QuaternionN(double qw, double qx, double qy, double qz,
                         double *x, double *y, double *z)
{
    Quaternion q = Quaternion::From(qw, qx, qy, qz);
    Vector v = q.RotationN();
    *x = v.x;
    *y = v.y;
    *z = v.z;
}

</t>
<t tx="leo.20171226104022.56">void Slvs_MakeQuaternion(double ux, double uy, double uz,
                         double vx, double vy, double vz,
                         double *qw, double *qx, double *qy, double *qz)
{
    Vector u = Vector::From(ux, uy, uz),
           v = Vector::From(vx, vy, vz);
    Quaternion q = Quaternion::From(u, v);
    *qw = q.w;
    *qx = q.vx;
    *qy = q.vy;
    *qz = q.vz;
}

</t>
<t tx="leo.20171226104022.57">void Slvs_Solve(Slvs_System *ssys, Slvs_hGroup shg)
{
    if(!IsInit) {
        InitPlatform(0, NULL);
        IsInit = 1;
    }

    int i;
    for(i = 0; i &lt; ssys-&gt;params; i++) {
        Slvs_Param *sp = &amp;(ssys-&gt;param[i]);
        Param p = {};

        p.h.v = sp-&gt;h;
        p.val = sp-&gt;val;
        SK.param.Add(&amp;p);
        if(sp-&gt;group == shg) {
            SYS.param.Add(&amp;p);
        }
    }

    for(i = 0; i &lt; ssys-&gt;entities; i++) {
        Slvs_Entity *se = &amp;(ssys-&gt;entity[i]);
        EntityBase e = {};

        switch(se-&gt;type) {
case SLVS_E_POINT_IN_3D:        e.type = Entity::Type::POINT_IN_3D; break;
case SLVS_E_POINT_IN_2D:        e.type = Entity::Type::POINT_IN_2D; break;
case SLVS_E_NORMAL_IN_3D:       e.type = Entity::Type::NORMAL_IN_3D; break;
case SLVS_E_NORMAL_IN_2D:       e.type = Entity::Type::NORMAL_IN_2D; break;
case SLVS_E_DISTANCE:           e.type = Entity::Type::DISTANCE; break;
case SLVS_E_WORKPLANE:          e.type = Entity::Type::WORKPLANE; break;
case SLVS_E_LINE_SEGMENT:       e.type = Entity::Type::LINE_SEGMENT; break;
case SLVS_E_CUBIC:              e.type = Entity::Type::CUBIC; break;
case SLVS_E_CIRCLE:             e.type = Entity::Type::CIRCLE; break;
case SLVS_E_ARC_OF_CIRCLE:      e.type = Entity::Type::ARC_OF_CIRCLE; break;

default: dbp("bad entity type %d", se-&gt;type); return;
        }
        e.h.v           = se-&gt;h;
        e.group.v       = se-&gt;group;
        e.workplane.v   = se-&gt;wrkpl;
        e.point[0].v    = se-&gt;point[0];
        e.point[1].v    = se-&gt;point[1];
        e.point[2].v    = se-&gt;point[2];
        e.point[3].v    = se-&gt;point[3];
        e.normal.v      = se-&gt;normal;
        e.distance.v    = se-&gt;distance;
        e.param[0].v    = se-&gt;param[0];
        e.param[1].v    = se-&gt;param[1];
        e.param[2].v    = se-&gt;param[2];
        e.param[3].v    = se-&gt;param[3];

        SK.entity.Add(&amp;e);
    }
    IdList&lt;Param, hParam&gt; params = {};
    for(i = 0; i &lt; ssys-&gt;constraints; i++) {
        Slvs_Constraint *sc = &amp;(ssys-&gt;constraint[i]);
        ConstraintBase c = {};

        Constraint::Type t;
        switch(sc-&gt;type) {
case SLVS_C_POINTS_COINCIDENT:  t = Constraint::Type::POINTS_COINCIDENT; break;
case SLVS_C_PT_PT_DISTANCE:     t = Constraint::Type::PT_PT_DISTANCE; break;
case SLVS_C_PT_PLANE_DISTANCE:  t = Constraint::Type::PT_PLANE_DISTANCE; break;
case SLVS_C_PT_LINE_DISTANCE:   t = Constraint::Type::PT_LINE_DISTANCE; break;
case SLVS_C_PT_FACE_DISTANCE:   t = Constraint::Type::PT_FACE_DISTANCE; break;
case SLVS_C_PT_IN_PLANE:        t = Constraint::Type::PT_IN_PLANE; break;
case SLVS_C_PT_ON_LINE:         t = Constraint::Type::PT_ON_LINE; break;
case SLVS_C_PT_ON_FACE:         t = Constraint::Type::PT_ON_FACE; break;
case SLVS_C_EQUAL_LENGTH_LINES: t = Constraint::Type::EQUAL_LENGTH_LINES; break;
case SLVS_C_LENGTH_RATIO:       t = Constraint::Type::LENGTH_RATIO; break;
case SLVS_C_EQ_LEN_PT_LINE_D:   t = Constraint::Type::EQ_LEN_PT_LINE_D; break;
case SLVS_C_EQ_PT_LN_DISTANCES: t = Constraint::Type::EQ_PT_LN_DISTANCES; break;
case SLVS_C_EQUAL_ANGLE:        t = Constraint::Type::EQUAL_ANGLE; break;
case SLVS_C_EQUAL_LINE_ARC_LEN: t = Constraint::Type::EQUAL_LINE_ARC_LEN; break;
case SLVS_C_LENGTH_DIFFERENCE:  t = Constraint::Type::LENGTH_DIFFERENCE; break;
case SLVS_C_SYMMETRIC:          t = Constraint::Type::SYMMETRIC; break;
case SLVS_C_SYMMETRIC_HORIZ:    t = Constraint::Type::SYMMETRIC_HORIZ; break;
case SLVS_C_SYMMETRIC_VERT:     t = Constraint::Type::SYMMETRIC_VERT; break;
case SLVS_C_SYMMETRIC_LINE:     t = Constraint::Type::SYMMETRIC_LINE; break;
case SLVS_C_AT_MIDPOINT:        t = Constraint::Type::AT_MIDPOINT; break;
case SLVS_C_HORIZONTAL:         t = Constraint::Type::HORIZONTAL; break;
case SLVS_C_VERTICAL:           t = Constraint::Type::VERTICAL; break;
case SLVS_C_DIAMETER:           t = Constraint::Type::DIAMETER; break;
case SLVS_C_PT_ON_CIRCLE:       t = Constraint::Type::PT_ON_CIRCLE; break;
case SLVS_C_SAME_ORIENTATION:   t = Constraint::Type::SAME_ORIENTATION; break;
case SLVS_C_ANGLE:              t = Constraint::Type::ANGLE; break;
case SLVS_C_PARALLEL:           t = Constraint::Type::PARALLEL; break;
case SLVS_C_PERPENDICULAR:      t = Constraint::Type::PERPENDICULAR; break;
case SLVS_C_ARC_LINE_TANGENT:   t = Constraint::Type::ARC_LINE_TANGENT; break;
case SLVS_C_CUBIC_LINE_TANGENT: t = Constraint::Type::CUBIC_LINE_TANGENT; break;
case SLVS_C_EQUAL_RADIUS:       t = Constraint::Type::EQUAL_RADIUS; break;
case SLVS_C_PROJ_PT_DISTANCE:   t = Constraint::Type::PROJ_PT_DISTANCE; break;
case SLVS_C_WHERE_DRAGGED:      t = Constraint::Type::WHERE_DRAGGED; break;
case SLVS_C_CURVE_CURVE_TANGENT:t = Constraint::Type::CURVE_CURVE_TANGENT; break;

default: dbp("bad constraint type %d", sc-&gt;type); return;
        }

        c.type = t;

        c.h.v           = sc-&gt;h;
        c.group.v       = sc-&gt;group;
        c.workplane.v   = sc-&gt;wrkpl;
        c.valA          = sc-&gt;valA;
        c.ptA.v         = sc-&gt;ptA;
        c.ptB.v         = sc-&gt;ptB;
        c.entityA.v     = sc-&gt;entityA;
        c.entityB.v     = sc-&gt;entityB;
        c.entityC.v     = sc-&gt;entityC;
        c.entityD.v     = sc-&gt;entityD;
        c.other         = (sc-&gt;other) ? true : false;
        c.other2        = (sc-&gt;other2) ? true : false;

        c.Generate(&amp;params);
        if(params.n &gt; 0) {
            for(Param &amp;p : params) {
                p.h = SK.param.AddAndAssignId(&amp;p);
                c.valP = p.h;
                SYS.param.Add(&amp;p);
            }
            params.Clear();
            c.ModifyToSatisfy();
        }

        SK.constraint.Add(&amp;c);
    }

    for(i = 0; i &lt; (int)arraylen(ssys-&gt;dragged); i++) {
        if(ssys-&gt;dragged[i]) {
            hParam hp = { ssys-&gt;dragged[i] };
            SYS.dragged.Add(&amp;hp);
        }
    }

    Group g = {};
    g.h.v = shg;

    List&lt;hConstraint&gt; bad = {};

    // Now we're finally ready to solve!
    bool andFindBad = ssys-&gt;calculateFaileds ? true : false;
    SolveResult how = SYS.Solve(&amp;g, &amp;(ssys-&gt;dof), &amp;bad, andFindBad, /*andFindFree=*/false);

    switch(how) {
        case SolveResult::OKAY:
            ssys-&gt;result = SLVS_RESULT_OKAY;
            break;

        case SolveResult::DIDNT_CONVERGE:
            ssys-&gt;result = SLVS_RESULT_DIDNT_CONVERGE;
            break;

        case SolveResult::REDUNDANT_DIDNT_CONVERGE:
        case SolveResult::REDUNDANT_OKAY:
            ssys-&gt;result = SLVS_RESULT_INCONSISTENT;
            break;

        case SolveResult::TOO_MANY_UNKNOWNS:
            ssys-&gt;result = SLVS_RESULT_TOO_MANY_UNKNOWNS;
            break;
    }

    // Write the new parameter values back to our caller.
    for(i = 0; i &lt; ssys-&gt;params; i++) {
        Slvs_Param *sp = &amp;(ssys-&gt;param[i]);
        hParam hp = { sp-&gt;h };
        sp-&gt;val = SK.GetParam(hp)-&gt;val;
    }

    if(ssys-&gt;failed) {
        // Copy over any the list of problematic constraints.
        for(i = 0; i &lt; ssys-&gt;faileds &amp;&amp; i &lt; bad.n; i++) {
            ssys-&gt;failed[i] = bad.elem[i].v;
        }
        ssys-&gt;faileds = bad.n;
    }

    bad.Clear();
    SYS.param.Clear();
    SYS.entity.Clear();
    SYS.eq.Clear();
    SYS.dragged.Clear();

    SK.param.Clear();
    SK.entity.Clear();
    SK.constraint.Clear();

    FreeAllTemporary();
}

</t>
<t tx="leo.20171226104022.58">//-----------------------------------------------------------------------------
// Once we've written our constraint equations in the symbolic algebra system,
// these routines linearize them, and solve by a modified Newton's method.
// This also contains the routines to detect non-convergence or inconsistency,
// and report diagnostics to the user.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

// This tolerance is used to determine whether two (linearized) constraints
// are linearly dependent. If this is too small, then we will attempt to
// solve truly inconsistent systems and fail. But if it's too large, then
// we will give up on legitimate systems like a skinny right angle triangle by
// its hypotenuse and long side.
const double System::RANK_MAG_TOLERANCE = 1e-4;

// The solver will converge all unknowns to within this tolerance. This must
// always be much less than LENGTH_EPS, and in practice should be much less.
const double System::CONVERGE_TOLERANCE = (LENGTH_EPS/(1e2));

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20171226104022.59">bool System::WriteJacobian(int tag) {
    int a, i, j;

    j = 0;
    for(a = 0; a &lt; param.n; a++) {
        if(j &gt;= MAX_UNKNOWNS) return false;

        Param *p = &amp;(param.elem[a]);
        if(p-&gt;tag != tag) continue;
        mat.param[j] = p-&gt;h;
        j++;
    }
    mat.n = j;

    i = 0;
    for(a = 0; a &lt; eq.n; a++) {
        if(i &gt;= MAX_UNKNOWNS) return false;

        Equation *e = &amp;(eq.elem[a]);
        if(e-&gt;tag != tag) continue;

        mat.eq[i] = e-&gt;h;
        Expr *f = e-&gt;e-&gt;DeepCopyWithParamsAsPointers(&amp;param, &amp;(SK.param));
        f = f-&gt;FoldConstants();

        // Hash table (61 bits) to accelerate generation of zero partials.
        uint64_t scoreboard = f-&gt;ParamsUsed();
        for(j = 0; j &lt; mat.n; j++) {
            Expr *pd;
            if(scoreboard &amp; ((uint64_t)1 &lt;&lt; (mat.param[j].v % 61)) &amp;&amp;
                f-&gt;DependsOn(mat.param[j]))
            {
                pd = f-&gt;PartialWrt(mat.param[j]);
                pd = pd-&gt;FoldConstants();
                pd = pd-&gt;DeepCopyWithParamsAsPointers(&amp;param, &amp;(SK.param));
            } else {
                pd = Expr::From(0.0);
            }
            mat.A.sym[i][j] = pd;
        }
        mat.B.sym[i] = f;
        i++;
    }
    mat.m = i;

    return true;
}

</t>
<t tx="leo.20171226104022.6">            constraint-&gt;HasLabel()) {
        constraint-&gt;reference = true;
    }
}

SS.GW.ClearSelection();
InvalidateGraphics();
</t>
<t tx="leo.20171226104022.60">void System::EvalJacobian() {
    int i, j;
    for(i = 0; i &lt; mat.m; i++) {
        for(j = 0; j &lt; mat.n; j++) {
            mat.A.num[i][j] = (mat.A.sym[i][j])-&gt;Eval();
        }
    }
}

</t>
<t tx="leo.20171226104022.61">bool System::IsDragged(hParam p) {
    hParam *pp;
    for(pp = dragged.First(); pp; pp = dragged.NextAfter(pp)) {
        if(p.v == pp-&gt;v) return true;
    }
    return false;
}

</t>
<t tx="leo.20171226104022.62">void System::SolveBySubstitution() {
    int i;
    for(i = 0; i &lt; eq.n; i++) {
        Equation *teq = &amp;(eq.elem[i]);
        Expr *tex = teq-&gt;e;

        if(tex-&gt;op    == Expr::Op::MINUS &amp;&amp;
           tex-&gt;a-&gt;op == Expr::Op::PARAM &amp;&amp;
           tex-&gt;b-&gt;op == Expr::Op::PARAM)
        {
            hParam a = tex-&gt;a-&gt;parh;
            hParam b = tex-&gt;b-&gt;parh;
            if(!(param.FindByIdNoOops(a) &amp;&amp; param.FindByIdNoOops(b))) {
                // Don't substitute unless they're both solver params;
                // otherwise it's an equation that can be solved immediately,
                // or an error to flag later.
                continue;
            }

            if(IsDragged(a)) {
                // A is being dragged, so A should stay, and B should go
                hParam t = a;
                a = b;
                b = t;
            }

            int j;
            for(j = 0; j &lt; eq.n; j++) {
                Equation *req = &amp;(eq.elem[j]);
                (req-&gt;e)-&gt;Substitute(a, b); // A becomes B, B unchanged
            }
            for(j = 0; j &lt; param.n; j++) {
                Param *rp = &amp;(param.elem[j]);
                if(rp-&gt;substd.v == a.v) {
                    rp-&gt;substd = b;
                }
            }
            Param *ptr = param.FindById(a);
            ptr-&gt;tag = VAR_SUBSTITUTED;
            ptr-&gt;substd = b;

            teq-&gt;tag = EQ_SUBSTITUTED;
        }
    }
}

//-----------------------------------------------------------------------------
// Calculate the rank of the Jacobian matrix, by Gram-Schimdt orthogonalization
// in place. A row (~equation) is considered to be all zeros if its magnitude
// is less than the tolerance RANK_MAG_TOLERANCE.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20171226104022.63">int System::CalculateRank() {
    // Actually work with magnitudes squared, not the magnitudes
    double rowMag[MAX_UNKNOWNS] = {};
    double tol = RANK_MAG_TOLERANCE*RANK_MAG_TOLERANCE;

    int i, iprev, j;
    int rank = 0;

    for(i = 0; i &lt; mat.m; i++) {
        // Subtract off this row's component in the direction of any
        // previous rows
        for(iprev = 0; iprev &lt; i; iprev++) {
            if(rowMag[iprev] &lt;= tol) continue; // ignore zero rows

            double dot = 0;
            for(j = 0; j &lt; mat.n; j++) {
                dot += (mat.A.num[iprev][j]) * (mat.A.num[i][j]);
            }
            for(j = 0; j &lt; mat.n; j++) {
                mat.A.num[i][j] -= (dot/rowMag[iprev])*mat.A.num[iprev][j];
            }
        }
        // Our row is now normal to all previous rows; calculate the
        // magnitude of what's left
        double mag = 0;
        for(j = 0; j &lt; mat.n; j++) {
            mag += (mat.A.num[i][j]) * (mat.A.num[i][j]);
        }
        if(mag &gt; tol) {
            rank++;
        }
        rowMag[i] = mag;
    }

    return rank;
}

</t>
<t tx="leo.20171226104022.64">bool System::TestRank() {
    EvalJacobian();
    return CalculateRank() == mat.m;
}

</t>
<t tx="leo.20171226104022.65">bool System::SolveLinearSystem(double X[], double A[][MAX_UNKNOWNS],
                               double B[], int n)
{
    // Gaussian elimination, with partial pivoting. It's an error if the
    // matrix is singular, because that means two constraints are
    // equivalent.
    int i, j, ip, jp, imax = 0;
    double max, temp;

    for(i = 0; i &lt; n; i++) {
        // We are trying eliminate the term in column i, for rows i+1 and
        // greater. First, find a pivot (between rows i and N-1).
        max = 0;
        for(ip = i; ip &lt; n; ip++) {
            if(ffabs(A[ip][i]) &gt; max) {
                imax = ip;
                max = ffabs(A[ip][i]);
            }
        }
        // Don't give up on a singular matrix unless it's really bad; the
        // assumption code is responsible for identifying that condition,
        // so we're not responsible for reporting that error.
        if(ffabs(max) &lt; 1e-20) continue;

        // Swap row imax with row i
        for(jp = 0; jp &lt; n; jp++) {
            swap(A[i][jp], A[imax][jp]);
        }
        swap(B[i], B[imax]);

        // For rows i+1 and greater, eliminate the term in column i.
        for(ip = i+1; ip &lt; n; ip++) {
            temp = A[ip][i]/A[i][i];

            for(jp = i; jp &lt; n; jp++) {
                A[ip][jp] -= temp*(A[i][jp]);
            }
            B[ip] -= temp*B[i];
        }
    }

    // We've put the matrix in upper triangular form, so at this point we
    // can solve by back-substitution.
    for(i = n - 1; i &gt;= 0; i--) {
        if(ffabs(A[i][i]) &lt; 1e-20) continue;

        temp = B[i];
        for(j = n - 1; j &gt; i; j--) {
            temp -= X[j]*A[i][j];
        }
        X[i] = temp / A[i][i];
    }

    return true;
}

</t>
<t tx="leo.20171226104022.66">bool System::SolveLeastSquares() {
    int r, c, i;

    // Scale the columns; this scale weights the parameters for the least
    // squares solve, so that we can encourage the solver to make bigger
    // changes in some parameters, and smaller in others.
    for(c = 0; c &lt; mat.n; c++) {
        if(IsDragged(mat.param[c])) {
            // It's least squares, so this parameter doesn't need to be all
            // that big to get a large effect.
            mat.scale[c] = 1/20.0;
        } else {
            mat.scale[c] = 1;
        }
        for(r = 0; r &lt; mat.m; r++) {
            mat.A.num[r][c] *= mat.scale[c];
        }
    }

    // Write A*A'
    for(r = 0; r &lt; mat.m; r++) {
        for(c = 0; c &lt; mat.m; c++) {  // yes, AAt is square
            double sum = 0;
            for(i = 0; i &lt; mat.n; i++) {
                sum += mat.A.num[r][i]*mat.A.num[c][i];
            }
            mat.AAt[r][c] = sum;
        }
    }

    if(!SolveLinearSystem(mat.Z, mat.AAt, mat.B.num, mat.m)) return false;

    // And multiply that by A' to get our solution.
    for(c = 0; c &lt; mat.n; c++) {
        double sum = 0;
        for(i = 0; i &lt; mat.m; i++) {
            sum += mat.A.num[i][c]*mat.Z[i];
        }
        mat.X[c] = sum * mat.scale[c];
    }
    return true;
}

</t>
<t tx="leo.20171226104022.67">bool System::NewtonSolve(int tag) {

    int iter = 0;
    bool converged = false;
    int i;

    // Evaluate the functions at our operating point.
    for(i = 0; i &lt; mat.m; i++) {
        mat.B.num[i] = (mat.B.sym[i])-&gt;Eval();
    }
    do {
        // And evaluate the Jacobian at our initial operating point.
        EvalJacobian();

        if(!SolveLeastSquares()) break;

        // Take the Newton step;
        //      J(x_n) (x_{n+1} - x_n) = 0 - F(x_n)
        for(i = 0; i &lt; mat.n; i++) {
            Param *p = param.FindById(mat.param[i]);
            p-&gt;val -= mat.X[i];
            if(isnan(p-&gt;val)) {
                // Very bad, and clearly not convergent
                return false;
            }
        }

        // Re-evalute the functions, since the params have just changed.
        for(i = 0; i &lt; mat.m; i++) {
            mat.B.num[i] = (mat.B.sym[i])-&gt;Eval();
        }
        // Check for convergence
        converged = true;
        for(i = 0; i &lt; mat.m; i++) {
            if(isnan(mat.B.num[i])) {
                return false;
            }
            if(ffabs(mat.B.num[i]) &gt; CONVERGE_TOLERANCE) {
                converged = false;
                break;
            }
        }
    } while(iter++ &lt; 50 &amp;&amp; !converged);

    return converged;
}

</t>
<t tx="leo.20171226104022.68">void System::WriteEquationsExceptFor(hConstraint hc, Group *g) {
    int i;
    // Generate all the equations from constraints in this group
    for(i = 0; i &lt; SK.constraint.n; i++) {
        ConstraintBase *c = &amp;(SK.constraint.elem[i]);
        if(c-&gt;group.v != g-&gt;h.v) continue;
        if(c-&gt;h.v == hc.v) continue;

        if(c-&gt;HasLabel() &amp;&amp; c-&gt;type != Constraint::Type::COMMENT &amp;&amp;
                g-&gt;allDimsReference)
        {
            // When all dimensions are reference, we adjust them to display
            // the correct value, and then don't generate any equations.
            c-&gt;ModifyToSatisfy();
            continue;
        }
        if(g-&gt;relaxConstraints &amp;&amp; c-&gt;type != Constraint::Type::POINTS_COINCIDENT) {
            // When the constraints are relaxed, we keep only the point-
            // coincident constraints, and the constraints generated by
            // the entities and groups.
            continue;
        }

        c-&gt;GenerateEquations(&amp;eq);
    }
    // And the equations from entities
    for(i = 0; i &lt; SK.entity.n; i++) {
        EntityBase *e = &amp;(SK.entity.elem[i]);
        if(e-&gt;group.v != g-&gt;h.v) continue;

        e-&gt;GenerateEquations(&amp;eq);
    }
    // And from the groups themselves
    g-&gt;GenerateEquations(&amp;eq);
}

</t>
<t tx="leo.20171226104022.69">void System::FindWhichToRemoveToFixJacobian(Group *g, List&lt;hConstraint&gt; *bad, bool forceDofCheck) {
    int a, i;

    for(a = 0; a &lt; 2; a++) {
        for(i = 0; i &lt; SK.constraint.n; i++) {
            ConstraintBase *c = &amp;(SK.constraint.elem[i]);
            if(c-&gt;group.v != g-&gt;h.v) continue;
            if((c-&gt;type == Constraint::Type::POINTS_COINCIDENT &amp;&amp; a == 0) ||
               (c-&gt;type != Constraint::Type::POINTS_COINCIDENT &amp;&amp; a == 1))
            {
                // Do the constraints in two passes: first everything but
                // the point-coincident constraints, then only those
                // constraints (so they appear last in the list).
                continue;
            }

            param.ClearTags();
            eq.Clear();
            WriteEquationsExceptFor(c-&gt;h, g);
            eq.ClearTags();

            // It's a major speedup to solve the easy ones by substitution here,
            // and that doesn't break anything.
            if(!forceDofCheck) {
                SolveBySubstitution();
            }

            WriteJacobian(0);
            EvalJacobian();

            int rank = CalculateRank();
            if(rank == mat.m) {
                // We fixed it by removing this constraint
                bad-&gt;Add(&amp;(c-&gt;h));
            }
        }
    }
}

SolveResult System::Solve(Group *g, int *dof, List&lt;hConstraint&gt; *bad,
</t>
<t tx="leo.20171226104022.7">//-----------------------------------------------------------------------------
// Given a constraint, generate one or more equations in our symbolic algebra
// system to represent that constraint; also various geometric helper
// functions for that.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

const hConstraint ConstraintBase::NO_CONSTRAINT = { 0 };

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20171226104022.70">                          bool andFindBad, bool andFindFree, bool forceDofCheck)
{
    WriteEquationsExceptFor(Constraint::NO_CONSTRAINT, g);

    int i;
    bool rankOk;

/*
    dbp("%d equations", eq.n);
    for(i = 0; i &lt; eq.n; i++) {
        dbp("  %.3f = %s = 0", eq.elem[i].e-&gt;Eval(), eq.elem[i].e-&gt;Print());
    }
    dbp("%d parameters", param.n);
    for(i = 0; i &lt; param.n; i++) {
        dbp("   param %08x at %.3f", param.elem[i].h.v, param.elem[i].val);
    } */

    // All params and equations are assigned to group zero.
    param.ClearTags();
    eq.ClearTags();

    if(!forceDofCheck) {
        SolveBySubstitution();
    }

    // Before solving the big system, see if we can find any equations that
    // are soluble alone. This can be a huge speedup. We don't know whether
    // the system is consistent yet, but if it isn't then we'll catch that
    // later.
    int alone = 1;
    for(i = 0; i &lt; eq.n; i++) {
        Equation *e = &amp;(eq.elem[i]);
        if(e-&gt;tag != 0) continue;

        hParam hp = e-&gt;e-&gt;ReferencedParams(&amp;param);
        if(hp.v == Expr::NO_PARAMS.v) continue;
        if(hp.v == Expr::MULTIPLE_PARAMS.v) continue;

        Param *p = param.FindById(hp);
        if(p-&gt;tag != 0) continue; // let rank test catch inconsistency

        e-&gt;tag = alone;
        p-&gt;tag = alone;
        WriteJacobian(alone);
        if(!NewtonSolve(alone)) {
            // We don't do the rank test, so let's arbitrarily return
            // the DIDNT_CONVERGE result here.
            rankOk = true;
            // Failed to converge, bail out early
            goto didnt_converge;
        }
        alone++;
    }

    // Now write the Jacobian for what's left, and do a rank test; that
    // tells us if the system is inconsistently constrained.
    if(!WriteJacobian(0)) {
        return SolveResult::TOO_MANY_UNKNOWNS;
    }

    rankOk = TestRank();

    // And do the leftovers as one big system
    if(!NewtonSolve(0)) {
        goto didnt_converge;
    }

    rankOk = TestRank();
    if(!rankOk) {
        if(!g-&gt;allowRedundant) {
            if(andFindBad) FindWhichToRemoveToFixJacobian(g, bad, forceDofCheck);
        }
    } else {
        // This is not the full Jacobian, but any substitutions or single-eq
        // solves removed one equation and one unknown, therefore no effect
        // on the number of DOF.
        if(dof) *dof = CalculateDof();
        MarkParamsFree(andFindFree);
    }
    // System solved correctly, so write the new values back in to the
    // main parameter table.
    for(i = 0; i &lt; param.n; i++) {
        Param *p = &amp;(param.elem[i]);
        double val;
        if(p-&gt;tag == VAR_SUBSTITUTED) {
            val = param.FindById(p-&gt;substd)-&gt;val;
        } else {
            val = p-&gt;val;
        }
        Param *pp = SK.GetParam(p-&gt;h);
        pp-&gt;val = val;
        pp-&gt;known = true;
        pp-&gt;free = p-&gt;free;
    }
    return rankOk ? SolveResult::OKAY : SolveResult::REDUNDANT_OKAY;

didnt_converge:
    SK.constraint.ClearTags();
    for(i = 0; i &lt; eq.n; i++) {
        if(ffabs(mat.B.num[i]) &gt; CONVERGE_TOLERANCE || isnan(mat.B.num[i])) {
            // This constraint is unsatisfied.
            if(!mat.eq[i].isFromConstraint()) continue;

            hConstraint hc = mat.eq[i].constraint();
            ConstraintBase *c = SK.constraint.FindByIdNoOops(hc);
            if(!c) continue;
            // Don't double-show constraints that generated multiple
            // unsatisfied equations
            if(!c-&gt;tag) {
                bad-&gt;Add(&amp;(c-&gt;h));
                c-&gt;tag = 1;
            }
        }
    }

    return rankOk ? SolveResult::DIDNT_CONVERGE : SolveResult::REDUNDANT_DIDNT_CONVERGE;
}

SolveResult System::SolveRank(Group *g, int *dof, List&lt;hConstraint&gt; *bad,
</t>
<t tx="leo.20171226104022.71">                              bool andFindBad, bool andFindFree, bool forceDofCheck)
{
    WriteEquationsExceptFor(Constraint::NO_CONSTRAINT, g);

    // All params and equations are assigned to group zero.
    param.ClearTags();
    eq.ClearTags();

    if(!forceDofCheck) {
        SolveBySubstitution();
    }

    // Now write the Jacobian, and do a rank test; that
    // tells us if the system is inconsistently constrained.
    if(!WriteJacobian(0)) {
        return SolveResult::TOO_MANY_UNKNOWNS;
    }

    bool rankOk = TestRank();
    if(!rankOk) {
        if(!g-&gt;allowRedundant) {
            if(andFindBad) FindWhichToRemoveToFixJacobian(g, bad, forceDofCheck);
        }
    } else {
        // This is not the full Jacobian, but any substitutions or single-eq
        // solves removed one equation and one unknown, therefore no effect
        // on the number of DOF.
        if(dof) *dof = CalculateDof();
        MarkParamsFree(andFindFree);
    }
    return rankOk ? SolveResult::OKAY : SolveResult::REDUNDANT_OKAY;
}

</t>
<t tx="leo.20171226104022.72">void System::Clear() {
    entity.Clear();
    param.Clear();
    eq.Clear();
    dragged.Clear();
}

</t>
<t tx="leo.20171226104022.73">void System::MarkParamsFree(bool find) {
    // If requested, find all the free (unbound) variables. This might be
    // more than the number of degrees of freedom. Don't always do this,
    // because the display would get annoying and it's slow.
    for(int i = 0; i &lt; param.n; i++) {
        Param *p = &amp;(param.elem[i]);
        p-&gt;free = false;

        if(find) {
            if(p-&gt;tag == 0) {
                p-&gt;tag = VAR_DOF_TEST;
                WriteJacobian(0);
                EvalJacobian();
                int rank = CalculateRank();
                if(rank == mat.m) {
                    p-&gt;free = true;
                }
                p-&gt;tag = 0;
            }
        }
    }
}

</t>
<t tx="leo.20171226104022.74">int System::CalculateDof() {
    return mat.n - mat.m;
}

</t>
<t tx="leo.20171226104022.75">//-----------------------------------------------------------------------------
// Utility functions, mostly various kinds of vector math (working on real
// numbers, not working on quantities in the symbolic algebra system).
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

std::string SolveSpace::ssprintf(const char *fmt, ...)
{
    va_list va;

    va_start(va, fmt);
    int size = vsnprintf(NULL, 0, fmt, va);
    ssassert(size &gt;= 0, "vsnprintf could not encode string");
    va_end(va);

    std::string result;
    result.resize(size + 1);

    va_start(va, fmt);
    vsnprintf(&amp;result[0], size + 1, fmt, va);
    va_end(va);

    result.resize(size);
    return result;
}

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20171226104022.76">char32_t utf8_iterator::operator*()
{
    const uint8_t *it = (const uint8_t*) this-&gt;p;
    char32_t result = *it;

    if((result &amp; 0x80) != 0) {
      unsigned int mask = 0x40;

      do {
        result &lt;&lt;= 6;
        unsigned int c = (*++it);
        mask   &lt;&lt;= 5;
        result  += c - 0x80;
      } while((result &amp; mask) != 0);

      result &amp;= mask - 1;
    }

    this-&gt;n = (const char*) (it + 1);
    return result;
}

</t>
<t tx="leo.20171226104022.77">int64_t SolveSpace::GetMilliseconds()
{
    auto timestamp = std::chrono::steady_clock::now().time_since_epoch();
    return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timestamp).count();
}

</t>
<t tx="leo.20171226104022.78">void SolveSpace::MakeMatrix(double *mat,
                            double a11, double a12, double a13, double a14,
                            double a21, double a22, double a23, double a24,
                            double a31, double a32, double a33, double a34,
                            double a41, double a42, double a43, double a44)
{
    mat[ 0] = a11;
    mat[ 1] = a21;
    mat[ 2] = a31;
    mat[ 3] = a41;
    mat[ 4] = a12;
    mat[ 5] = a22;
    mat[ 6] = a32;
    mat[ 7] = a42;
    mat[ 8] = a13;
    mat[ 9] = a23;
    mat[10] = a33;
    mat[11] = a43;
    mat[12] = a14;
    mat[13] = a24;
    mat[14] = a34;
    mat[15] = a44;
}

</t>
<t tx="leo.20171226104022.79">void SolveSpace::MultMatrix(double *mata, double *matb, double *matr) {
    for(int i = 0; i &lt; 4; i++) {
        for(int j = 0; j &lt; 4; j++) {
            double s = 0.0;
            for(int k = 0; k &lt; 4; k++) {
                s += mata[k * 4 + j] * matb[i * 4 + k];
            }
           matr[i * 4 + j] = s;
        }
    }
}

//-----------------------------------------------------------------------------
// Word-wrap the string for our message box appropriately, and then display
// that string.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20171226104022.8">bool ConstraintBase::HasLabel() const {
    switch(type) {
        case Type::PT_LINE_DISTANCE:
        case Type::PT_PLANE_DISTANCE:
        case Type::PT_FACE_DISTANCE:
        case Type::PT_PT_DISTANCE:
        case Type::PROJ_PT_DISTANCE:
        case Type::DIAMETER:
        case Type::LENGTH_RATIO:
        case Type::LENGTH_DIFFERENCE:
        case Type::ANGLE:
        case Type::COMMENT:
            return true;

        default:
            return false;
    }
}

ExprVector ConstraintBase::VectorsParallel3d(ExprVector a, ExprVector b, hParam p) {
    return a.Minus(b.ScaledBy(Expr::From(p)));
}

Expr *ConstraintBase::PointLineDistance(hEntity wrkpl, hEntity hpt, hEntity hln)
{
    EntityBase *ln = SK.GetEntity(hln);
    EntityBase *a = SK.GetEntity(ln-&gt;point[0]);
    EntityBase *b = SK.GetEntity(ln-&gt;point[1]);

    EntityBase *p = SK.GetEntity(hpt);

    if(wrkpl.v == EntityBase::FREE_IN_3D.v) {
        ExprVector ep = p-&gt;PointGetExprs();

        ExprVector ea = a-&gt;PointGetExprs();
        ExprVector eb = b-&gt;PointGetExprs();
        ExprVector eab = ea.Minus(eb);
        Expr *m = eab.Magnitude();

        return ((eab.Cross(ea.Minus(ep))).Magnitude())-&gt;Div(m);
    } else {
        Expr *ua, *va, *ub, *vb;
        a-&gt;PointGetExprsInWorkplane(wrkpl, &amp;ua, &amp;va);
        b-&gt;PointGetExprsInWorkplane(wrkpl, &amp;ub, &amp;vb);

        Expr *du = ua-&gt;Minus(ub);
        Expr *dv = va-&gt;Minus(vb);

        Expr *u, *v;
        p-&gt;PointGetExprsInWorkplane(wrkpl, &amp;u, &amp;v);

        Expr *m = ((du-&gt;Square())-&gt;Plus(dv-&gt;Square()))-&gt;Sqrt();

        Expr *proj = (dv-&gt;Times(ua-&gt;Minus(u)))-&gt;Minus(
                     (du-&gt;Times(va-&gt;Minus(v))));

        return proj-&gt;Div(m);
    }
}

Expr *ConstraintBase::PointPlaneDistance(ExprVector p, hEntity hpl) {
    ExprVector n;
    Expr *d;
    SK.GetEntity(hpl)-&gt;WorkplaneGetPlaneExprs(&amp;n, &amp;d);
    return (p.Dot(n))-&gt;Minus(d);
}

Expr *ConstraintBase::Distance(hEntity wrkpl, hEntity hpa, hEntity hpb) {
    EntityBase *pa = SK.GetEntity(hpa);
    EntityBase *pb = SK.GetEntity(hpb);
    ssassert(pa-&gt;IsPoint() &amp;&amp; pb-&gt;IsPoint(),
             "Expected two points to measure projected distance between");

    if(wrkpl.v == EntityBase::FREE_IN_3D.v) {
        // This is true distance
        ExprVector ea, eb, eab;
        ea = pa-&gt;PointGetExprs();
        eb = pb-&gt;PointGetExprs();
        eab = ea.Minus(eb);

        return eab.Magnitude();
    } else {
        // This is projected distance, in the given workplane.
        Expr *au, *av, *bu, *bv;

        pa-&gt;PointGetExprsInWorkplane(wrkpl, &amp;au, &amp;av);
        pb-&gt;PointGetExprsInWorkplane(wrkpl, &amp;bu, &amp;bv);

        Expr *du = au-&gt;Minus(bu);
        Expr *dv = av-&gt;Minus(bv);

        return ((du-&gt;Square())-&gt;Plus(dv-&gt;Square()))-&gt;Sqrt();
    }
}

//-----------------------------------------------------------------------------
// Return the cosine of the angle between two vectors. If a workplane is
// specified, then it's the cosine of their projections into that workplane.
//-----------------------------------------------------------------------------
Expr *ConstraintBase::DirectionCosine(hEntity wrkpl,
                                      ExprVector ae, ExprVector be)
{
    if(wrkpl.v == EntityBase::FREE_IN_3D.v) {
        Expr *mags = (ae.Magnitude())-&gt;Times(be.Magnitude());
        return (ae.Dot(be))-&gt;Div(mags);
    } else {
        EntityBase *w = SK.GetEntity(wrkpl);
        ExprVector u = w-&gt;Normal()-&gt;NormalExprsU();
        ExprVector v = w-&gt;Normal()-&gt;NormalExprsV();
        Expr *ua = u.Dot(ae);
        Expr *va = v.Dot(ae);
        Expr *ub = u.Dot(be);
        Expr *vb = v.Dot(be);
        Expr *maga = (ua-&gt;Square()-&gt;Plus(va-&gt;Square()))-&gt;Sqrt();
        Expr *magb = (ub-&gt;Square()-&gt;Plus(vb-&gt;Square()))-&gt;Sqrt();
        Expr *dot = (ua-&gt;Times(ub))-&gt;Plus(va-&gt;Times(vb));
        return dot-&gt;Div(maga-&gt;Times(magb));
    }
}

ExprVector ConstraintBase::PointInThreeSpace(hEntity workplane,
                                             Expr *u, Expr *v)
{
    EntityBase *w = SK.GetEntity(workplane);

    ExprVector ub = w-&gt;Normal()-&gt;NormalExprsU();
    ExprVector vb = w-&gt;Normal()-&gt;NormalExprsV();
    ExprVector ob = w-&gt;WorkplaneGetOffsetExprs();

    return (ub.ScaledBy(u)).Plus(vb.ScaledBy(v)).Plus(ob);
}

</t>
<t tx="leo.20171226104022.80">static void DoStringForMessageBox(const char *str, va_list f, bool error)
{
    char inBuf[1024*50];
    vsprintf(inBuf, str, f);

    char outBuf[1024*50];
    int i = 0, j = 0, len = 0, longestLen = 47;
    int rows = 0, cols = 0;

    // Count the width of the longest line that starts with spaces; those
    // are list items, that should not be split in the middle.
    bool listLine = false;
    while(inBuf[i]) {
        if(inBuf[i] == '\r') {
            // ignore these
        } else if(inBuf[i] == ' ' &amp;&amp; len == 0) {
            listLine = true;
        } else if(inBuf[i] == '\n') {
            if(listLine) longestLen = max(longestLen, len);
            len = 0;
        } else {
            len++;
        }
        i++;
    }
    if(listLine) longestLen = max(longestLen, len);

    // Word wrap according to our target line length longestLen.
    len = 0;
    i = 0;
    while(inBuf[i]) {
        if(inBuf[i] == '\r') {
            // ignore these
        } else if(inBuf[i] == '\n') {
            outBuf[j++] = '\n';
            if(len == 0) rows++;
            len = 0;
        } else if(inBuf[i] == ' ' &amp;&amp; len &gt; longestLen) {
            outBuf[j++] = '\n';
            len = 0;
        } else {
            outBuf[j++] = inBuf[i];
            // Count rows when we draw the first character; so an empty
            // row doesn't end up counting.
            if(len == 0) rows++;
            len++;
        }
        cols = max(cols, len);
        i++;
    }
    outBuf[j++] = '\0';

    // And then display the text with our actual longest line length.
    DoMessageBox(outBuf, rows, cols, error);
}
</t>
<t tx="leo.20171226104022.81">void SolveSpace::Error(const char *str, ...)
{
    va_list f;
    va_start(f, str);
    DoStringForMessageBox(str, f, /*error=*/true);
    va_end(f);
}
</t>
<t tx="leo.20171226104022.82">void SolveSpace::Message(const char *str, ...)
{
    va_list f;
    va_start(f, str);
    DoStringForMessageBox(str, f, /*error=*/false);
    va_end(f);
}

void SolveSpace::CnfFreezeBool(bool v, const std::string &amp;name)

//-----------------------------------------------------------------------------
// Solve a mostly banded matrix. In a given row, there are LEFT_OF_DIAG
// elements to the left of the diagonal element, and RIGHT_OF_DIAG elements to
// the right (so that the total band width is LEFT_OF_DIAG + RIGHT_OF_DIAG + 1).
// There also may be elements in the last two columns of any row. We solve
// without pivoting.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20171226104022.83">void BandedMatrix::Solve() {
    int i, ip, j, jp;
    double temp;

    // Reduce the matrix to upper triangular form.
    for(i = 0; i &lt; n; i++) {
        for(ip = i+1; ip &lt; n &amp;&amp; ip &lt;= (i + LEFT_OF_DIAG); ip++) {
            temp = A[ip][i]/A[i][i];

            for(jp = i; jp &lt; (n - 2) &amp;&amp; jp &lt;= (i + RIGHT_OF_DIAG); jp++) {
                A[ip][jp] -= temp*(A[i][jp]);
            }
            A[ip][n-2] -= temp*(A[i][n-2]);
            A[ip][n-1] -= temp*(A[i][n-1]);

            B[ip] -= temp*B[i];
        }
    }

    // And back-substitute.
    for(i = n - 1; i &gt;= 0; i--) {
        temp = B[i];

        if(i &lt; n-1) temp -= X[n-1]*A[i][n-1];
        if(i &lt; n-2) temp -= X[n-2]*A[i][n-2];

        for(j = min(n - 3, i + RIGHT_OF_DIAG); j &gt; i; j--) {
            temp -= X[j]*A[i][j];
        }
        X[i] = temp / A[i][i];
    }
}

const Quaternion Quaternion::IDENTITY = { 1, 0, 0, 0 };

Quaternion Quaternion::From(double w, double vx, double vy, double vz) {
    Quaternion q;
    q.w  = w;
    q.vx = vx;
    q.vy = vy;
    q.vz = vz;
    return q;
}

Quaternion Quaternion::From(hParam w, hParam vx, hParam vy, hParam vz) {
    Quaternion q;
    q.w  = SK.GetParam(w )-&gt;val;
    q.vx = SK.GetParam(vx)-&gt;val;
    q.vy = SK.GetParam(vy)-&gt;val;
    q.vz = SK.GetParam(vz)-&gt;val;
    return q;
}

Quaternion Quaternion::From(Vector axis, double dtheta) {
    Quaternion q;
    double c = cos(dtheta / 2), s = sin(dtheta / 2);
    axis = axis.WithMagnitude(s);
    q.w  = c;
    q.vx = axis.x;
    q.vy = axis.y;
    q.vz = axis.z;
    return q;
}

Quaternion Quaternion::From(Vector u, Vector v)
{
    Vector n = u.Cross(v);

    Quaternion q;
    double s, tr = 1 + u.x + v.y + n.z;
    if(tr &gt; 1e-4) {
        s = 2*sqrt(tr);
        q.w  = s/4;
        q.vx = (v.z - n.y)/s;
        q.vy = (n.x - u.z)/s;
        q.vz = (u.y - v.x)/s;
    } else {
        if(u.x &gt; v.y &amp;&amp; u.x &gt; n.z) {
            s = 2*sqrt(1 + u.x - v.y - n.z);
            q.w  = (v.z - n.y)/s;
            q.vx = s/4;
            q.vy = (u.y + v.x)/s;
            q.vz = (n.x + u.z)/s;
        } else if(v.y &gt; n.z) {
            s = 2*sqrt(1 - u.x + v.y - n.z);
            q.w  = (n.x - u.z)/s;
            q.vx = (u.y + v.x)/s;
            q.vy = s/4;
            q.vz = (v.z + n.y)/s;
        } else {
            s = 2*sqrt(1 - u.x - v.y + n.z);
            q.w  = (u.y - v.x)/s;
            q.vx = (n.x + u.z)/s;
            q.vy = (v.z + n.y)/s;
            q.vz = s/4;
        }
    }

    return q.WithMagnitude(1);
}

Quaternion Quaternion::Plus(Quaternion b) const {
    Quaternion q;
    q.w  = w  + b.w;
    q.vx = vx + b.vx;
    q.vy = vy + b.vy;
    q.vz = vz + b.vz;
    return q;
}

Quaternion Quaternion::Minus(Quaternion b) const {
    Quaternion q;
    q.w  = w  - b.w;
    q.vx = vx - b.vx;
    q.vy = vy - b.vy;
    q.vz = vz - b.vz;
    return q;
}

Quaternion Quaternion::ScaledBy(double s) const {
    Quaternion q;
    q.w  = w*s;
    q.vx = vx*s;
    q.vy = vy*s;
    q.vz = vz*s;
    return q;
}

double Quaternion::Magnitude() const {
    return sqrt(w*w + vx*vx + vy*vy + vz*vz);
}

Quaternion Quaternion::WithMagnitude(double s) const {
    return ScaledBy(s/Magnitude());
}

Vector Quaternion::RotationU() const {
    Vector v;
    v.x = w*w + vx*vx - vy*vy - vz*vz;
    v.y = 2*w *vz + 2*vx*vy;
    v.z = 2*vx*vz - 2*w *vy;
    return v;
}

Vector Quaternion::RotationV() const {
    Vector v;
    v.x = 2*vx*vy - 2*w*vz;
    v.y = w*w - vx*vx + vy*vy - vz*vz;
    v.z = 2*w*vx + 2*vy*vz;
    return v;
}

Vector Quaternion::RotationN() const {
    Vector v;
    v.x = 2*w*vy + 2*vx*vz;
    v.y = 2*vy*vz - 2*w*vx;
    v.z = w*w - vx*vx - vy*vy + vz*vz;
    return v;
}

Vector Quaternion::Rotate(Vector p) const {
    // Express the point in the new basis
    return (RotationU().ScaledBy(p.x)).Plus(
            RotationV().ScaledBy(p.y)).Plus(
            RotationN().ScaledBy(p.z));
}

Quaternion Quaternion::Inverse() const {
    Quaternion r;
    r.w = w;
    r.vx = -vx;
    r.vy = -vy;
    r.vz = -vz;
    return r.WithMagnitude(1); // not that the normalize should be reqd
}

Quaternion Quaternion::ToThe(double p) const {
    // Avoid division by zero, or arccos of something not in its domain
    if(w &gt;= (1 - 1e-6)) {
        return From(1, 0, 0, 0);
    } else if(w &lt;= (-1 + 1e-6)) {
        return From(-1, 0, 0, 0);
    }

    Quaternion r;
    Vector axis = Vector::From(vx, vy, vz);
    double theta = acos(w); // okay, since magnitude is 1, so -1 &lt;= w &lt;= 1
    theta *= p;
    r.w = cos(theta);
    axis = axis.WithMagnitude(sin(theta));
    r.vx = axis.x;
    r.vy = axis.y;
    r.vz = axis.z;
    return r;
}

Quaternion Quaternion::Times(Quaternion b) const {
    double sa = w, sb = b.w;
    Vector va = { vx, vy, vz };
    Vector vb = { b.vx, b.vy, b.vz };

    Quaternion r;
    r.w = sa*sb - va.Dot(vb);
    Vector vr = vb.ScaledBy(sa).Plus(
                va.ScaledBy(sb).Plus(
                va.Cross(vb)));
    r.vx = vr.x;
    r.vy = vr.y;
    r.vz = vr.z;
    return r;
}

Quaternion Quaternion::Mirror() const {
    Vector u = RotationU(),
           v = RotationV();
    u = u.ScaledBy(-1);
    v = v.ScaledBy(-1);
    return Quaternion::From(u, v);
}


Vector Vector::From(double x, double y, double z) {
    Vector v;
    v.x = x; v.y = y; v.z = z;
    return v;
}

Vector Vector::From(hParam x, hParam y, hParam z) {
    Vector v;
    v.x = SK.GetParam(x)-&gt;val;
    v.y = SK.GetParam(y)-&gt;val;
    v.z = SK.GetParam(z)-&gt;val;
    return v;
}

double Vector::Element(int i) const {
    switch(i) {
        case 0: return x;
        case 1: return y;
        case 2: return z;
        default: ssassert(false, "Unexpected vector element index");
    }
}

</t>
<t tx="leo.20171226104022.84">bool Vector::Equals(Vector v, double tol) const {
    // Quick axis-aligned tests before going further
    double dx = v.x - x; if(dx &lt; -tol || dx &gt; tol) return false;
    double dy = v.y - y; if(dy &lt; -tol || dy &gt; tol) return false;
    double dz = v.z - z; if(dz &lt; -tol || dz &gt; tol) return false;

    return (this-&gt;Minus(v)).MagSquared() &lt; tol*tol;
}

</t>
<t tx="leo.20171226104022.85">bool Vector::EqualsExactly(Vector v) const {
    return EXACT(x == v.x &amp;&amp;
                 y == v.y &amp;&amp;
                 z == v.z);
}

Vector Vector::Plus(Vector b) const {
    Vector r;

    r.x = x + b.x;
    r.y = y + b.y;
    r.z = z + b.z;

    return r;
}

Vector Vector::Minus(Vector b) const {
    Vector r;

    r.x = x - b.x;
    r.y = y - b.y;
    r.z = z - b.z;

    return r;
}

Vector Vector::Negated() const {
    Vector r;

    r.x = -x;
    r.y = -y;
    r.z = -z;

    return r;
}

Vector Vector::Cross(Vector b) const {
    Vector r;

    r.x = -(z*b.y) + (y*b.z);
    r.y =  (z*b.x) - (x*b.z);
    r.z = -(y*b.x) + (x*b.y);

    return r;
}

double Vector::Dot(Vector b) const {
    return (x*b.x + y*b.y + z*b.z);
}

double Vector::DirectionCosineWith(Vector b) const {
    Vector a = this-&gt;WithMagnitude(1);
    b = b.WithMagnitude(1);
    return a.Dot(b);
}

Vector Vector::Normal(int which) const {
    Vector n;

    // Arbitrarily choose one vector that's normal to us, pivoting
    // appropriately.
    double xa = fabs(x), ya = fabs(y), za = fabs(z);
    if(this-&gt;Equals(Vector::From(0, 0, 1))) {
        // Make DXFs exported in the XY plane work nicely...
        n = Vector::From(1, 0, 0);
    } else if(xa &lt; ya &amp;&amp; xa &lt; za) {
        n.x = 0;
        n.y = z;
        n.z = -y;
    } else if(ya &lt; za) {
        n.x = -z;
        n.y = 0;
        n.z = x;
    } else {
        n.x = y;
        n.y = -x;
        n.z = 0;
    }

    if(which == 0) {
        // That's the vector we return.
    } else if(which == 1) {
        n = this-&gt;Cross(n);
    } else ssassert(false, "Unexpected vector normal index");

    n = n.WithMagnitude(1);

    return n;
}

Vector Vector::RotatedAbout(Vector orig, Vector axis, double theta) const {
    Vector r = this-&gt;Minus(orig);
    r = r.RotatedAbout(axis, theta);
    return r.Plus(orig);
}

Vector Vector::RotatedAbout(Vector axis, double theta) const {
    double c = cos(theta);
    double s = sin(theta);

    axis = axis.WithMagnitude(1);

    Vector r;

    r.x =   (x)*(c + (1 - c)*(axis.x)*(axis.x)) +
            (y)*((1 - c)*(axis.x)*(axis.y) - s*(axis.z)) +
            (z)*((1 - c)*(axis.x)*(axis.z) + s*(axis.y));

    r.y =   (x)*((1 - c)*(axis.y)*(axis.x) + s*(axis.z)) +
            (y)*(c + (1 - c)*(axis.y)*(axis.y)) +
            (z)*((1 - c)*(axis.y)*(axis.z) - s*(axis.x));

    r.z =   (x)*((1 - c)*(axis.z)*(axis.x) - s*(axis.y)) +
            (y)*((1 - c)*(axis.z)*(axis.y) + s*(axis.x)) +
            (z)*(c + (1 - c)*(axis.z)*(axis.z));

    return r;
}

Vector Vector::DotInToCsys(Vector u, Vector v, Vector n) const {
    Vector r = {
        this-&gt;Dot(u),
        this-&gt;Dot(v),
        this-&gt;Dot(n)
    };
    return r;
}

Vector Vector::ScaleOutOfCsys(Vector u, Vector v, Vector n) const {
    Vector r = u.ScaledBy(x).Plus(
               v.ScaledBy(y).Plus(
               n.ScaledBy(z)));
    return r;
}

Vector Vector::InPerspective(Vector u, Vector v, Vector n,
                             Vector origin, double cameraTan) const
{
    Vector r = this-&gt;Minus(origin);
    r = r.DotInToCsys(u, v, n);
    // yes, minus; we are assuming a csys where u cross v equals n, backwards
    // from the display stuff
    double w = (1 - r.z*cameraTan);
    r = r.ScaledBy(1/w);

    return r;
}

double Vector::DistanceToLine(Vector p0, Vector dp) const {
    double m = dp.Magnitude();
    return ((this-&gt;Minus(p0)).Cross(dp)).Magnitude() / m;
}

double Vector::DistanceToPlane(Vector normal, Vector origin) const {
    return this-&gt;Dot(normal) - origin.Dot(normal);
}

</t>
<t tx="leo.20171226104022.86">bool Vector::OnLineSegment(Vector a, Vector b, double tol) const {
    if(this-&gt;Equals(a, tol) || this-&gt;Equals(b, tol)) return true;

    Vector d = b.Minus(a);

    double m = d.MagSquared();
    double distsq = ((this-&gt;Minus(a)).Cross(d)).MagSquared() / m;

    if(distsq &gt;= tol*tol) return false;

    double t = (this-&gt;Minus(a)).DivPivoting(d);
    // On-endpoint already tested
    if(t &lt; 0 || t &gt; 1) return false;
    return true;
}

Vector Vector::ClosestPointOnLine(Vector p0, Vector dp) const {
    dp = dp.WithMagnitude(1);
    // this, p0, and (p0+dp) define a plane; the min distance is in
    // that plane, so calculate its normal
    Vector pn = (this-&gt;Minus(p0)).Cross(dp);
    // The minimum distance line is in that plane, perpendicular
    // to the line
    Vector n = pn.Cross(dp);

    // Calculate the actual distance
    double d = (dp.Cross(p0.Minus(*this))).Magnitude();
    return this-&gt;Plus(n.WithMagnitude(d));
}

double Vector::MagSquared() const {
    return x*x + y*y + z*z;
}

double Vector::Magnitude() const {
    return sqrt(x*x + y*y + z*z);
}

Vector Vector::ScaledBy(double v) const {
    Vector r;

    r.x = x * v;
    r.y = y * v;
    r.z = z * v;

    return r;
}

Vector Vector::WithMagnitude(double v) const {
    double m = Magnitude();
    if(EXACT(m == 0)) {
        // We can do a zero vector with zero magnitude, but not any other cases.
        if(fabs(v) &gt; 1e-100) {
            dbp("Vector::WithMagnitude(%g) of zero vector!", v);
        }
        return From(0, 0, 0);
    } else {
        return ScaledBy(v/m);
    }
}

Vector Vector::ProjectVectorInto(hEntity wrkpl) const {
    EntityBase *w = SK.GetEntity(wrkpl);
    Vector u = w-&gt;Normal()-&gt;NormalU();
    Vector v = w-&gt;Normal()-&gt;NormalV();

    double up = this-&gt;Dot(u);
    double vp = this-&gt;Dot(v);

    return (u.ScaledBy(up)).Plus(v.ScaledBy(vp));
}

Vector Vector::ProjectInto(hEntity wrkpl) const {
    EntityBase *w = SK.GetEntity(wrkpl);
    Vector p0 = w-&gt;WorkplaneGetOffset();

    Vector f = this-&gt;Minus(p0);

    return p0.Plus(f.ProjectVectorInto(wrkpl));
}

Point2d Vector::Project2d(Vector u, Vector v) const {
    Point2d p;
    p.x = this-&gt;Dot(u);
    p.y = this-&gt;Dot(v);
    return p;
}

Point2d Vector::ProjectXy() const {
    Point2d p;
    p.x = x;
    p.y = y;
    return p;
}

Vector4 Vector::Project4d() const {
    return Vector4::From(1, x, y, z);
}

double Vector::DivPivoting(Vector delta) const {
    double mx = fabs(delta.x), my = fabs(delta.y), mz = fabs(delta.z);

    if(mx &gt; my &amp;&amp; mx &gt; mz) {
        return x/delta.x;
    } else if(my &gt; mz) {
        return y/delta.y;
    } else {
        return z/delta.z;
    }
}

Vector Vector::ClosestOrtho() const {
    double mx = fabs(x), my = fabs(y), mz = fabs(z);

    if(mx &gt; my &amp;&amp; mx &gt; mz) {
        return From((x &gt; 0) ? 1 : -1, 0, 0);
    } else if(my &gt; mz) {
        return From(0, (y &gt; 0) ? 1 : -1, 0);
    } else {
        return From(0, 0, (z &gt; 0) ? 1 : -1);
    }
}

Vector Vector::ClampWithin(double minv, double maxv) const {
    Vector ret = *this;

    if(ret.x &lt; minv) ret.x = minv;
    if(ret.y &lt; minv) ret.y = minv;
    if(ret.z &lt; minv) ret.z = minv;

    if(ret.x &gt; maxv) ret.x = maxv;
    if(ret.y &gt; maxv) ret.y = maxv;
    if(ret.z &gt; maxv) ret.z = maxv;

    return ret;
}

</t>
<t tx="leo.20171226104022.87">void Vector::MakeMaxMin(Vector *maxv, Vector *minv) const {
    maxv-&gt;x = max(maxv-&gt;x, x);
    maxv-&gt;y = max(maxv-&gt;y, y);
    maxv-&gt;z = max(maxv-&gt;z, z);

    minv-&gt;x = min(minv-&gt;x, x);
    minv-&gt;y = min(minv-&gt;y, y);
    minv-&gt;z = min(minv-&gt;z, z);
}

</t>
<t tx="leo.20171226104022.88">bool Vector::OutsideAndNotOn(Vector maxv, Vector minv) const {
    return (x &gt; maxv.x + LENGTH_EPS) || (x &lt; minv.x - LENGTH_EPS) ||
           (y &gt; maxv.y + LENGTH_EPS) || (y &lt; minv.y - LENGTH_EPS) ||
           (z &gt; maxv.z + LENGTH_EPS) || (z &lt; minv.z - LENGTH_EPS);
}

</t>
<t tx="leo.20171226104022.89">bool Vector::BoundingBoxesDisjoint(Vector amax, Vector amin,
                                   Vector bmax, Vector bmin)
{
    int i;
    for(i = 0; i &lt; 3; i++) {
        if(amax.Element(i) &lt; bmin.Element(i) - LENGTH_EPS) return true;
        if(amin.Element(i) &gt; bmax.Element(i) + LENGTH_EPS) return true;
    }
    return false;
}

</t>
<t tx="leo.20171226104022.9">void ConstraintBase::ModifyToSatisfy() {
    if(type == Type::ANGLE) {
        Vector a = SK.GetEntity(entityA)-&gt;VectorGetNum();
        Vector b = SK.GetEntity(entityB)-&gt;VectorGetNum();
        if(other) a = a.ScaledBy(-1);
        if(workplane.v != EntityBase::FREE_IN_3D.v) {
            a = a.ProjectVectorInto(workplane);
            b = b.ProjectVectorInto(workplane);
        }
        double c = (a.Dot(b))/(a.Magnitude() * b.Magnitude());
        valA = acos(c)*180/PI;
    } else if(type == Type::PT_ON_LINE) {
        EntityBase *eln = SK.GetEntity(entityA);
        EntityBase *ea = SK.GetEntity(eln-&gt;point[0]);
        EntityBase *eb = SK.GetEntity(eln-&gt;point[1]);
        EntityBase *ep = SK.GetEntity(ptA);
        ExprVector exp = ep-&gt;PointGetExprsInWorkplane(workplane);
        ExprVector exa = ea-&gt;PointGetExprsInWorkplane(workplane);
        ExprVector exb = eb-&gt;PointGetExprsInWorkplane(workplane);
        ExprVector exba = exb.Minus(exa);
        SK.GetParam(valP)-&gt;val = exba.Dot(exp.Minus(exa))-&gt;Eval() / exba.Dot(exba)-&gt;Eval();
    } else {
        // We'll fix these ones up by looking at their symbolic equation;
        // that means no extra work.
        IdList&lt;Equation,hEquation&gt; l = {};
        // Generate the equations even if this is a reference dimension
        GenerateEquations(&amp;l, /*forReference=*/true);
        ssassert(l.n == 1, "Expected constraint to generate a single equation");

        // These equations are written in the form f(...) - d = 0, where
        // d is the value of the valA.
        valA += (l.elem[0].e)-&gt;Eval();

        l.Clear();
    }
}

</t>
<t tx="leo.20171226104022.90">bool Vector::BoundingBoxIntersectsLine(Vector amax, Vector amin,
                                       Vector p0, Vector p1, bool asSegment)
{
    Vector dp = p1.Minus(p0);
    double lp = dp.Magnitude();
    dp = dp.ScaledBy(1.0/lp);

    int i, a;
    for(i = 0; i &lt; 3; i++) {
        int j = WRAP(i+1, 3), k = WRAP(i+2, 3);
        if(lp*fabs(dp.Element(i)) &lt; LENGTH_EPS) continue; // parallel to plane

        for(a = 0; a &lt; 2; a++) {
            double d = (a == 0) ? amax.Element(i) : amin.Element(i);
            // n dot (p0 + t*dp) = d
            // (n dot p0) + t * (n dot dp) = d
            double t = (d - p0.Element(i)) / dp.Element(i);
            Vector p = p0.Plus(dp.ScaledBy(t));

            if(asSegment &amp;&amp; (t &lt; -LENGTH_EPS || t &gt; (lp+LENGTH_EPS))) continue;

            if(p.Element(j) &gt; amax.Element(j) + LENGTH_EPS) continue;
            if(p.Element(k) &gt; amax.Element(k) + LENGTH_EPS) continue;

            if(p.Element(j) &lt; amin.Element(j) - LENGTH_EPS) continue;
            if(p.Element(k) &lt; amin.Element(k) - LENGTH_EPS) continue;

            return true;
        }
    }

    return false;
}

Vector Vector::AtIntersectionOfPlanes(Vector n1, double d1,
                                      Vector n2, double d2)
{
    double det = (n1.Dot(n1))*(n2.Dot(n2)) -
{
    // Make a semi-orthogonal coordinate system from those directions;
    // note that dna and dnb need not be perpendicular.
    Vector dn = da.Cross(db); // normal to both
    Vector dna = dn.Cross(da); // normal to da
    Vector dnb = dn.Cross(db); // normal to db

    // At the intersection of the lines
    //    a0 + pa*da = b0 + pb*db (where pa, pb are scalar params)
    // So dot this equation against dna and dnb to get two equations
    // to solve for da and db
    *tb =  ((a0.Minus(b0)).Dot(dna))/(db.Dot(dna));
    *ta = -((a0.Minus(b0)).Dot(dnb))/(da.Dot(dnb));
}

Vector Vector::AtIntersectionOfLines(Vector a0, Vector a1,
                                     Vector b0, Vector b1,
                                     bool *skew,
                                     double *parama, double *paramb)
{
    Vector da = a1.Minus(a0), db = b1.Minus(b0);

    double pa, pb;
    Vector::ClosestPointBetweenLines(a0, da, b0, db, &amp;pa, &amp;pb);

    if(parama) *parama = pa;
    if(paramb) *paramb = pb;

    // And from either of those, we get the intersection point.
    Vector pi = a0.Plus(da.ScaledBy(pa));

    if(skew) {
        // Check if the intersection points on each line are actually
        // coincident...
        if(pi.Equals(b0.Plus(db.ScaledBy(pb)))) {
            *skew = false;
        } else {
            *skew = true;
        }
    }
    return pi;
}

Vector Vector::AtIntersectionOfPlaneAndLine(Vector n, double d,
                                            Vector p0, Vector p1,
                                            bool *parallel)
{
    Vector dp = p1.Minus(p0);

    if(fabs(n.Dot(dp)) &lt; LENGTH_EPS) {
        if(parallel) *parallel = true;
        return Vector::From(0, 0, 0);
    }

    if(parallel) *parallel = false;

    // n dot (p0 + t*dp) = d
    // (n dot p0) + t * (n dot dp) = d
    double t = (d - n.Dot(p0)) / (n.Dot(dp));

    return p0.Plus(dp.ScaledBy(t));
}

</t>
<t tx="leo.20171226104022.91">static double det2(double a1, double b1,
                   double a2, double b2)
{
    return (a1*b2) - (b1*a2);
}
</t>
<t tx="leo.20171226104022.92">static double det3(double a1, double b1, double c1,
                   double a2, double b2, double c2,
                   double a3, double b3, double c3)
{
    return a1*det2(b2, c2, b3, c3) -
           b1*det2(a2, c2, a3, c3) +
           c1*det2(a2, b2, a3, b3);
}
Vector Vector::AtIntersectionOfPlanes(Vector na, double da,
                                      Vector nb, double db,
                                      Vector nc, double dc,
                                      bool *parallel)
{
</t>
<t tx="leo.20171226104022.93">    double det  = det3(na.x, na.y, na.z,
                       nb.x, nb.y, nb.z,
                       nc.x, nc.y, nc.z);
    if(fabs(det) &lt; 1e-10) { // arbitrary tolerance, not so good
        *parallel = true;
        return Vector::From(0, 0, 0);
    }
    *parallel = false;

    double detx = det3(da,   na.y, na.z,

    return Vector::From(detx/det, dety/det, detz/det);
}

size_t VectorHash::operator()(const Vector &amp;v) const {
    const size_t size = (size_t)pow(std::numeric_limits&lt;size_t&gt;::max(), 1.0 / 3.0) - 1;
    const double eps = 4.0 * LENGTH_EPS;

    double x = fabs(v.x) / eps;
    double y = fabs(v.y) / eps;
    double z = fabs(v.y) / eps;

    size_t xs = size_t(fmod(x, (double)size));
    size_t ys = size_t(fmod(y, (double)size));
    size_t zs = size_t(fmod(z, (double)size));

    return (zs * size + ys) * size + xs;
}

</t>
<t tx="leo.20171226104022.94">bool VectorPred::operator()(Vector a, Vector b) const {
    return a.Equals(b, LENGTH_EPS);
}

Vector4 Vector4::From(double w, double x, double y, double z) {
    Vector4 ret;
    ret.w = w;
    ret.x = x;
    ret.y = y;
    ret.z = z;
    return ret;
}

Vector4 Vector4::From(double w, Vector v) {
    return Vector4::From(w, w*v.x, w*v.y, w*v.z);
}

Vector4 Vector4::Blend(Vector4 a, Vector4 b, double t) {
    return (a.ScaledBy(1 - t)).Plus(b.ScaledBy(t));
}

Vector4 Vector4::Plus(Vector4 b) const {
    return Vector4::From(w + b.w, x + b.x, y + b.y, z + b.z);
}

Vector4 Vector4::Minus(Vector4 b) const {
    return Vector4::From(w - b.w, x - b.x, y - b.y, z - b.z);
}

Vector4 Vector4::ScaledBy(double s) const {
    return Vector4::From(w*s, x*s, y*s, z*s);
}

Vector Vector4::PerspectiveProject() const {
    return Vector::From(x / w, y / w, z / w);
}

Point2d Point2d::From(double x, double y) {
    return { x, y };
}

Point2d Point2d::FromPolar(double r, double a) {
    return { r * cos(a), r * sin(a) };
}

double Point2d::Angle() const {
    double a = atan2(y, x);
    return M_PI + remainder(a - M_PI, 2 * M_PI);
}

double Point2d::AngleTo(const Point2d &amp;p) const {
    return p.Minus(*this).Angle();
}

Point2d Point2d::Plus(const Point2d &amp;b) const {
    return { x + b.x, y + b.y };
}

Point2d Point2d::Minus(const Point2d &amp;b) const {
    return { x - b.x, y - b.y };
}

Point2d Point2d::ScaledBy(double s) const {
    return { x * s, y * s };
}

double Point2d::DivPivoting(Point2d delta) const {
    if(fabs(delta.x) &gt; fabs(delta.y)) {
        return x/delta.x;
    } else {
        return y/delta.y;
    }
}

double Point2d::MagSquared() const {
    return x*x + y*y;
}

double Point2d::Magnitude() const {
    return sqrt(x*x + y*y);
}

Point2d Point2d::WithMagnitude(double v) const {
    double m = Magnitude();
    if(m &lt; 1e-20) {
        dbp("!!! WithMagnitude() of zero vector");
        return { v, 0 };
    }
    return { x * v / m, y * v / m };
}

double Point2d::DistanceTo(const Point2d &amp;p) const {
    double dx = x - p.x;
    double dy = y - p.y;
    return sqrt(dx*dx + dy*dy);
}

double Point2d::Dot(Point2d p) const {
    return x*p.x + y*p.y;
}

double Point2d::DistanceToLine(const Point2d &amp;p0, const Point2d &amp;dp, bool asSegment) const {
    double m = dp.x*dp.x + dp.y*dp.y;
    if(m &lt; LENGTH_EPS*LENGTH_EPS) return VERY_POSITIVE;

    // Let our line be p = p0 + t*dp, for a scalar t from 0 to 1
    double t = (dp.x*(x - p0.x) + dp.y*(y - p0.y))/m;

    if(asSegment) {
        if(t &lt; 0.0) return DistanceTo(p0);
        if(t &gt; 1.0) return DistanceTo(p0.Plus(dp));
    }
    Point2d closest = p0.Plus(dp.ScaledBy(t));
    return DistanceTo(closest);
}

double Point2d::DistanceToLineSigned(const Point2d &amp;p0, const Point2d &amp;dp, bool asSegment) const {
    double m = dp.x*dp.x + dp.y*dp.y;
    if(m &lt; LENGTH_EPS*LENGTH_EPS) return VERY_POSITIVE;

    Point2d n = dp.Normal().WithMagnitude(1.0);
    double dist = n.Dot(*this) - n.Dot(p0);
    if(asSegment) {
        // Let our line be p = p0 + t*dp, for a scalar t from 0 to 1
        double t = (dp.x*(x - p0.x) + dp.y*(y - p0.y))/m;
        double sign = (dist &gt; 0.0) ? 1.0 : -1.0;
        if(t &lt; 0.0) return DistanceTo(p0) * sign;
        if(t &gt; 1.0) return DistanceTo(p0.Plus(dp)) * sign;
    }

    return dist;
}

Point2d Point2d::Normal() const {
    return { y, -x };
}

</t>
<t tx="leo.20171226104022.95">bool Point2d::Equals(Point2d v, double tol) const {
    double dx = v.x - x; if(dx &lt; -tol || dx &gt; tol) return false;
    double dy = v.y - y; if(dy &lt; -tol || dy &gt; tol) return false;

    return (this-&gt;Minus(v)).MagSquared() &lt; tol*tol;
}

BBox BBox::From(const Vector &amp;p0, const Vector &amp;p1) {
    BBox bbox;
    bbox.minp.x = min(p0.x, p1.x);
    bbox.minp.y = min(p0.y, p1.y);
    bbox.minp.z = min(p0.z, p1.z);

    bbox.maxp.x = max(p0.x, p1.x);
    bbox.maxp.y = max(p0.y, p1.y);
    bbox.maxp.z = max(p0.z, p1.z);
    return bbox;
}

Vector BBox::GetOrigin() const { return minp.Plus(maxp.Minus(minp).ScaledBy(0.5)); }
Vector BBox::GetExtents() const { return maxp.Minus(minp).ScaledBy(0.5); }

</t>
<t tx="leo.20171226104022.96">void BBox::Include(const Vector &amp;v, double r) {
    minp.x = min(minp.x, v.x - r);
    minp.y = min(minp.y, v.y - r);
    minp.z = min(minp.z, v.z - r);

    maxp.x = max(maxp.x, v.x + r);
    maxp.y = max(maxp.y, v.y + r);
    maxp.z = max(maxp.z, v.z + r);
}

</t>
<t tx="leo.20171226104022.97">bool BBox::Overlaps(const BBox &amp;b1) const {
    Vector t = b1.GetOrigin().Minus(GetOrigin());
    Vector e = b1.GetExtents().Plus(GetExtents());

    return fabs(t.x) &lt; e.x &amp;&amp; fabs(t.y) &lt; e.y &amp;&amp; fabs(t.z) &lt; e.z;
}

</t>
<t tx="leo.20171226104022.98">bool BBox::Contains(const Point2d &amp;p, double r) const {
    return p.x &gt;= (minp.x - r) &amp;&amp;
           p.y &gt;= (minp.y - r) &amp;&amp;
           p.x &lt;= (maxp.x + r) &amp;&amp;
           p.y &lt;= (maxp.y + r);
}

</t>
<t tx="leo.20171226104022.99">const std::vector&lt;double&gt;&amp; SolveSpace::StipplePatternDashes(StipplePattern pattern) {
    static bool initialized;
    static std::vector&lt;double&gt; dashes[(size_t)StipplePattern::LAST + 1];
    if(!initialized) {
        // Inkscape ignores all elements that are exactly zero instead of drawing
        // them as dots, so set those to 1e-6.
        dashes[(size_t)StipplePattern::CONTINUOUS] =
            {};
        dashes[(size_t)StipplePattern::SHORT_DASH] =
            { 1.0, 2.0 };
        dashes[(size_t)StipplePattern::DASH] =
            { 1.0, 1.0 };
        dashes[(size_t)StipplePattern::DASH_DOT] =
            { 1.0, 0.5, 1e-6, 0.5 };
        dashes[(size_t)StipplePattern::DASH_DOT_DOT] =
            { 1.0, 0.5, 1e-6, 0.5, 0.5, 1e-6 };
        dashes[(size_t)StipplePattern::DOT] =
            { 1e-6, 0.5 };
        dashes[(size_t)StipplePattern::LONG_DASH] =
            { 2.0, 0.5 };
        dashes[(size_t)StipplePattern::FREEHAND] =
            { 1.0, 2.0 };
        dashes[(size_t)StipplePattern::ZIGZAG] =
            { 1.0, 2.0 };
    }

    return dashes[(size_t)pattern];
}

double SolveSpace::StipplePatternLength(StipplePattern pattern) {
    static bool initialized;
    static double lengths[(size_t)StipplePattern::LAST + 1];
    if(!initialized) {
        for(size_t i = 0; i &lt; (size_t)StipplePattern::LAST; i++) {
            const std::vector&lt;double&gt; &amp;dashes = StipplePatternDashes((StipplePattern)i);
            double length = 0.0;
            for(double dash : dashes) {
                length += dash;
            }
            lengths[i] = length;
        }
    }

    return lengths[(size_t)pattern];
}
</t>
<t tx="leo.20171226104343.1"></t>
<t tx="leo.20171226104343.4">#一三角形呆鍊，由一長一短的連桿固定在水平基線上。
#短連桿鎖固在原點上，長連桿鎖固在距原點90mm處。
#短連桿長度35mm；長連桿長度70mm。
#三角形呆鍊邊長分別為40mm、40mm、70mm
@others
@language python
@tabwidth -4
</t>
<t tx="leo.20171226104343.5">from slvs import *
from math import *

#相關參數
d0 = 90 #基線長度(mm)
n1 = 35 #短連桿長度(mm)
n2 = 70 #長連桿長度(mm)
t1 = 40 #三角形第一邊(mm)
t2 = 40 #三角形第二邊(mm)
t3 = 70 #三角形第三邊(mm)

#開始繪圖

</t>
<t tx="leo.20171226104343.6">def crank_rock(degree):
    sys = System(500)
    group = 1
    #原點Point0
    p0 = sys.add_param(0.0)
    p1 = sys.add_param(0.0)
    p2 = sys.add_param(0.0)
    Point0 = Point3d(p0, p1, p2)

    #XY法線
    qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
    p3 = sys.add_param(qw)
    p4 = sys.add_param(qx)
    p5 = sys.add_param(qy)
    p6 = sys.add_param(qz)
    Normal1 = Normal3d(p3, p4, p5, p6)

    #工作平面
    Workplane1 = Workplane(Point0, Normal1)

    #3D版的Point0=&gt;Point1
    p7 = sys.add_param(0.0)
    p8 = sys.add_param(0.0)
    Point1 = Point2d(Workplane1, p7, p8)
    Constraint.dragged(Workplane1, Point1)

    #長連桿轉軸Point2，還有基線Line0。
    p9 = sys.add_param(d0)
    p10 = sys.add_param(0.0)
    Point2 = Point2d(Workplane1, p9, p10)
    Constraint.dragged(Workplane1, Point2)
    Line0 = LineSegment2d(Workplane1, Point1, Point2)

    #Angle約束判斷
    if degree &gt;= 180:
        other = -1
    else:
        other = 1

    #三角形Point3 / Point4 / Point5
    p11 = sys.add_param(20.0)
    p12 = sys.add_param(20.0)
    Point3 = Point2d(Workplane1, p11, p12)
    p13 = sys.add_param(0.0)
    p14 = sys.add_param(10.0*other)
    Point4 = Point2d(Workplane1, p13, p14)
    p15 = sys.add_param(30.0)
    p16 = sys.add_param(20.0)
    Point5 = Point2d(Workplane1, p15, p16)
    Constraint.distance(t1, Workplane1, Point4, Point3)
    Constraint.distance(t2, Workplane1, Point3, Point5)
    Constraint.distance(t3, Workplane1, Point4, Point5)

    #連桿約束
    Constraint.distance(n1, Workplane1, Point1, Point4)
    Constraint.distance(n2, Workplane1, Point2, Point5)
    Line1 = LineSegment2d(Workplane1, Point1, Point4)

    #短連桿與水平軸的角度
    Constraint.angle(Workplane1, degree, Line1, Line0)

    #以下解題

    result = sys.solve()

    if result == SLVS_RESULT_OKAY:
        g.es("點座標：")
        g.es(("P3(%.3f %.3f %.3f)")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val))
        g.es(("P4(%.3f %.3f %.3f)")%(sys.get_param(13).val, sys.get_param(14).val, sys.get_param(2).val))
        g.es("%d DOF" % sys.dof)
    elif result == SLVS_RESULT_INCONSISTENT:
        g.es("solve failed")
        g.es("SLVS_RESULT_INCONSISTENT")
        g.es("%d DOF" % sys.dof)
    elif result == SLVS_RESULT_DIDNT_CONVERGE:
        g.es("solve failed")
        g.es("SLVS_RESULT_DIDNT_CONVERGE")
        g.es("%d DOF" % sys.dof)
    elif result == SLVS_RESULT_TOO_MANY_UNKNOWNS:
        g.es("solve failed")
        g.es("SLVS_RESULT_TOO_MANY_UNKNOWNS")
        g.es("%d DOF" % sys.dof)

#主程式
for i in range(0, 360, 10):
    g.es("Degree: {:03} deg".format(i))
    crank_rock(i)
g.es("Solve Completed")
</t>
<t tx="leo.20171226104343.7">@others
@language python
@tabwidth -4
</t>
<t tx="leo.20171226104507.1"># -*- coding: utf-8 -*-
## Some sample code for slvs.dll. We draw some geometric entities, provide
## initial guesses for their positions, and then constrain them. The solver
## calculates their new positions, in order to satisfy the constraints.
##
## Copyright 2008-2013 Jonathan Westhues.
## Copyright 2016-2017 Yuan Chang [pyslvs@gmail.com] Python-Solvespace bundled.

@others
if __name__=='__main__':
    Example3d()
    Example2d()

'''
solved okay
line from (10.000 11.180) to (10.000 -18.820)
arc center (101.114 119.042) start (116.477 111.762) finish (117.409 114.197)
circle center (200.000 200.000) radius 17.000
6 DOF
'''
@language python
@tabwidth -4
</t>
<t tx="leo.20171226104507.2">from slvs import *

sys = System()

'''
An example of a constraint in 3d. We create a single group, with some
entities and constraints.
'''
</t>
<t tx="leo.20171226104507.3">def Example3d():
    #A point, initially at (x y z) = (10 10 10)
    p0 = sys.add_param(10)
    p1 = sys.add_param(10)
    p2 = sys.add_param(10)
    Point101 = Point3d(p0, p1, p2)

    #and a second point at (20 20 20)
    p3 = sys.add_param(20)
    p4 = sys.add_param(20)
    p5 = sys.add_param(20)
    Point102 = Point3d(p3, p4, p5)

    #and a line segment connecting them.
    LineSegment3d(Point101, Point102)

    #The distance between the points should be 30.0 units.
    Constraint.distance(30., Point101, Point102)

    #Let's tell the solver to keep the second point as close to constant
    #as possible, instead moving the first point.
    Constraint.dragged(Point102)
    
    #Now that we have written our system, we solve.
    result = sys.solve()
    g.es(50*"*")
    if result == SLVS_RESULT_OKAY:
        g.es("Solve 3D demo start")
        g.es(
            "okay; now at ({:.3f} {:.3f} {:.3f})\n".format(sys.get_param(0).val, sys.get_param(1).val, sys.get_param(2).val)+
            "             ({:.3f} {:.3f} {:.3f})\n".format(sys.get_param(3).val, sys.get_param(4).val, sys.get_param(5).val)
        )
        g.es("{} DOF".format(sys.dof))
        g.es("Solve 3D demo completed")
    else:
        g.es("solve failed")
    g.es(50*"*")

'''
An example of a constraint in 2d. In our first group, we create a workplane
along the reference frame's xy plane. In a second group, we create some
entities in that group and dimension them.
'''
</t>
<t tx="leo.20171226104507.4">def Example2d():
    g1 = groupNum(1)
    sys.default_group = g1

    #First, we create our workplane. Its origin corresponds to the origin
    #of our base frame (x y z) = (0 0 0)
    p0 = sys.add_param(0)
    p1 = sys.add_param(0)
    p2 = sys.add_param(0)
    Point101 = Point3d(p0, p1, p2)

    #and it is parallel to the xy plane, so it has basis vectors (1 0 0)
    #and (0 1 0).
    qw, qx, qy, qz = Slvs_MakeQuaternion(*[1, 0, 0], *[0, 1, 0])
    p3 = sys.add_param(qw)
    p4 = sys.add_param(qx)
    p5 = sys.add_param(qy)
    p6 = sys.add_param(qz)
    Normal102 = Normal3d(p3, p4, p5, p6)

    Workplane200 = Workplane(Point101, Normal102)

    #Now create a second group. We'll solve group 2, while leaving group 1
    #constant; so the workplane that we've created will be locked down,
    #and the solver can't move it.
    g2 = groupNum(2)
    sys.default_group = g2

    #These points are represented by their coordinates (u v) within the
    #workplane, so they need only two parameters each.
    p7 = sys.add_param(10)
    p8 = sys.add_param(20)
    Point301 = Point2d(Workplane200, p7, p8)

    p9 = sys.add_param(20)
    p10 = sys.add_param(10)
    Point302 = Point2d(Workplane200, p9, p10)

    #And we create a line segment with those endpoints.
    Line400 = LineSegment2d(Workplane200, Point301, Point302)

    #Now three more points.
    p11 = sys.add_param(100)
    p12 = sys.add_param(120)
    Point303 = Point2d(Workplane200, p11, p12)

    p13 = sys.add_param(120)
    p14 = sys.add_param(110)
    Point304 = Point2d(Workplane200, p13, p14)

    p15 = sys.add_param(115)
    p16 = sys.add_param(115)
    Point305 = Point2d(Workplane200, p15, p16)

    #And arc, centered at point 303, starting at point 304, ending at
    #point 305.
    Arc401 = ArcOfCircle(Workplane200, Normal102, Point303, Point304, Point305)

    #Now one more point, and a distance
    p17 = sys.add_param(200)
    p18 = sys.add_param(200)
    Point306 = Point2d(Workplane200, p17, p18)

    p19 = sys.add_param(30)
    Distance307 = Distance(Workplane200, p19)

    #And a complete circle, centered at point 306 with radius equal to
    #distance 307. The normal is 102, the same as our workplane.
    Circle402 = Circle(Workplane200, Normal102, Point306, Distance307)

    #The length of our line segment is 30.0 units.
    Constraint.distance(30., Workplane200, Point301, Point302)

    #And the distance from our line segment to the origin is 10.0 units.
    Constraint.distance(10., Workplane200, Point101, Line400)

    #And the line segment is vertical.
    Constraint.vertical(Workplane200, Line400)

    #And the distance from one endpoint to the origin is 15.0 units.
    Constraint.distance(15., Workplane200, Point301, Point101)

    if 0:
        #And same for the other endpoint; so if you add this constraint then
        #the sketch is overconstrained and will signal an error.
        Constraint.distance(18., Workplane200, Point301, Point101)

    #The arc and the circle have equal radius.
    Constraint.equal_radius(Workplane200, Arc401, Circle402)

    #The arc has radius 17.0 units.
    Constraint.diameter(17.*2, Workplane200, Arc401)

    #If the solver fails, then ask it to report which constraints caused
    #the problem.
    sys.calculateFaileds = 1

    #And solve.
    result = sys.solve()
    g.es(50*"*")
    if result == SLVS_RESULT_OKAY:
        g.es("solved okay")
        #Python-Solvespace can use wrapper of pointer to get the values,
        #or record the entry number first, then using the 'get_param' method.
        g.es("line from ({:.3f} {:.3f}) to ({:.3f} {:.3f})".format(
            Point301.u().value, Point301.v().value, #(sys.get_param(7).val, sys.get_param(8).val) is okay.
            Point302.u().value, Point302.v().value
        ))
        g.es("arc center ({:.3f} {:.3f}) start ({:.3f} {:.3f}) finish ({:.3f} {:.3f})".format(
            Point303.u().value, Point303.v().value, #(sys.get_param(11).val, sys.get_param(12).val) is okay.
            Point304.u().value, Point304.v().value,
            Point305.u().value, Point305.v().value
        ))
        g.es("circle center ({:.3f} {:.3f}) radius {:.3f}".format(
            Point306.u().value, Point306.v().value,
            Distance307.distance().value
        ))
        g.es("{} DOF".format(sys.dof))
    else:
        g.es("solve failed: problematic constraints are:")
        for e in sys.faileds:
            g.es(e)
        if result == SLVS_RESULT_INCONSISTENT:
            g.es("system inconsistent")
        else:
            g.es("system nonconvergent")
    g.es(50*"*")
</t>
<t tx="leo.20171226105123.1"></t>
<t tx="leo.20171226105217.1">import os

os.chdir("./../")
os.system("mingw32-make")
g.es("mingw32-make done")</t>
<t tx="leo.20171226111411.1">'''
python3 -m pip install matplotlib
Point1 (0, 0)
Point2(90, 0)
link1 length 35
link2 length 70
link3 length 70
triangle length 70, 40, 40
'''
from slvs import *
from math import *
import matplotlib.pyplot as plt

# variables
d0 = 90
n1 = 35
n2 = 70
t1 = 40
t2 = 40
t3 = 70

# use moving reference frame as p2 prime, increment angel is 5 degree
</t>
<t tx="leo.20171226111411.2">def crank_rocker(degree, p2x, p2y, p3x, p3y, p4x, p4y, p5x, p5y):
    sys = System()
    g = 1
    # origin Point zero
    p0 = sys.add_param(0.0)
    p1 = sys.add_param(0.0)
    p2 = sys.add_param(0.0)
    Point0 = Point3d(p0, p1, p2)

    # add normal vector
    qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
    p3 = sys.add_param(qw)
    p4 = sys.add_param(qx)
    p5 = sys.add_param(qy)
    p6 = sys.add_param(qz)
    Normal1 = Normal3d(p3, p4, p5, p6)

    # add workplane
    Workplane1 = Workplane(Point0, Normal1)

    # convert 3D point to 2D point
    p7 = sys.add_param(0.0)
    p8 = sys.add_param(0.0)
    Point1 = Point2d(Workplane1, p7, p8)
    Constraint.dragged(Workplane1, Point1)

    #add Point2 and Line0
    p9 = sys.add_param(d0)
    p10 = sys.add_param(0.0)
    Point2 = Point2d(Workplane1, p9, p10)
    Constraint.dragged(Workplane1, Point2)
    
    p11 = sys.add_param(p2x)
    p12 = sys.add_param(p2y)
    moving2 = Point2d(Workplane1, p11, p12)
    Constraint.dragged(Workplane1, moving2)
    # Line0 depends on Point1 and moving2
    Line0 = LineSegment2d(Workplane1, Point1, moving2)

    # triangle Point4- Point3-Point5
    p13 = sys.add_param(p3x)
    p14 = sys.add_param(p3y)
    Point3 = Point2d(Workplane1, p13, p14)
    p15 = sys.add_param(p4x)
    p16 = sys.add_param(p4y)
    Point4 = Point2d(Workplane1, p15, p16)
    p17 = sys.add_param(p5x)
    p18 = sys.add_param(p5y)
    Point5 = Point2d(Workplane1, p17, p18)
    Constraint.distance(t1, Workplane1, Point4, Point3)
    Constraint.distance(t2, Workplane1, Point3, Point5)
    Constraint.distance(t3, Workplane1, Point4, Point5)

    # add Line1 and link length constraints
    Constraint.distance(n1, Workplane1, Point1, Point4)
    Constraint.distance(n2, Workplane1, Point2, Point5)
    Line1 = LineSegment2d(Workplane1, Point1, Point4)

    #add rotation angle constraint
    Constraint.angle(Workplane1, degree, Line1, Line0, False)

    #solve for results
    sys.calculateFaileds = 1;

    sys.solve()
    result = sys.result

    if(result == SLVS_RESULT_OKAY):

        # return coordinates of Point3
        return sys.get_param(13).val, sys.get_param(14).val, sys.get_param(15).val, sys.get_param(16).val, sys.get_param(17).val, sys.get_param(18).val

    elif (result == SLVS_RESULT_INCONSISTENT):
        print ("solve failed", degree)
        print ("SLVS_RESULT_INCONSISTENT")
        print ("%d DOF" % sys.dof)
    elif (result == SLVS_RESULT_DIDNT_CONVERGE):
        print ("solve failed")
        print ("SLVS_RESULT_DIDNT_CONVERGE")
        print ("%d DOF" % sys.dof)
    elif (result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
        print ("solve failed")
        print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
        print ("%d DOF" % sys.dof)

# main program
Xval  = []
Yval  = []
inc = 5
# initially Point3, Point4, Point5 coordinate
p3x = 20
p3y = 20
p4x = 0
p4y = 10
p5x = 30
p5y = 20
for i in range(0, 360+inc*3, inc):
    # moving reference point
    p2x = d0*cos(i*pi/180)
    p2y = d0*sin(i*pi/180)
    try:
        p3x, p3y, p4x, p4y, p5x, p5y = crank_rocker(inc, p2x, p2y, p3x, p3y, p4x, p4y, p5x, p5y)
        Xval += [p3x]
        Yval += [p3y]
        print(i, ":", round(p3x, 4), round(p3y, 4))
    except:
        pass
print ("Solve Completed")

plt.plot(Xval, Yval)
plt.xlabel('x coordinate')
plt.ylabel('y coordinate')
plt.show()
</t>
<t tx="leo.20171226165445.1">http://www.swig.org/

http://www.swig.org/Doc3.0/SWIGDocumentation.pdf </t>
</tnodes>
</leo_file>
